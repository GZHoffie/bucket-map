--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         16777216 B, 64 B, 16-way associative
Command:          ./bucket_map_benchmark
Data file:        cachegrind.out.3183
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                         I1mr           ILmr           Dr                       D1mr                    DLmr                   Dw                       D1mw                   DLmw                
--------------------------------------------------------------------------------
2,329,044,044,104 (100.0%) 8,101 (100.0%) 7,119 (100.0%) 476,501,146,518 (100.0%) 10,296,606,045 (100.0%) 1,666,303,482 (100.0%) 586,964,940,218 (100.0%) 5,701,082,670 (100.0%) 86,560,623 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                       I1mr           ILmr           Dr                       D1mr                   DLmr                   Dw                       D1mw                   DLmw                 file:function
--------------------------------------------------------------------------------
512,553,469,049 (22.01%)     6 ( 0.07%)     6 ( 0.08%) 200,221,587,032 (42.02%)    60,758,711 ( 0.59%)             0          133,201,737,408 (22.69%)   333,170,529 ( 5.84%)        313 ( 0.00%)  /usr/include/c++/11/bitset:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
327,343,764,477 (14.05%)    24 ( 0.30%)    22 ( 0.31%)       2,573,218 ( 0.00%)     1,286,441 ( 0.01%)             0          327,321,887,429 (55.77%) 5,114,934,125 (89.72%)     90,972 ( 0.11%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
259,715,357,764 (11.15%)    11 ( 0.14%)    11 ( 0.15%)  30,755,713,037 ( 6.45%)    26,739,392 ( 0.26%)    26,711,315 ( 1.60%)   1,708,719,937 ( 0.29%)        26,506 ( 0.00%)          0           /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/search/views/kmer_hash.hpp:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
191,369,184,477 ( 8.22%)     2 ( 0.02%)     2 ( 0.03%)         185,549 ( 0.00%)        26,507 ( 0.00%)             1 ( 0.00%)         185,549 ( 0.00%)             0                   0           /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/utility/container/dynamic_bitset.hpp:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
152,088,716,317 ( 6.53%)    79 ( 0.98%)    65 ( 0.91%)  42,982,042,239 ( 9.02%)   757,596,821 ( 7.36%)       574,390 ( 0.03%)  17,964,773,882 ( 3.06%)     2,715,802 ( 0.05%)      1,074 ( 0.00%)  ./malloc/./malloc/malloc.c:_int_free
 95,053,264,454 ( 4.08%)    16 ( 0.20%)    16 ( 0.22%)   9,946,812,848 ( 2.09%)     1,161,185 ( 0.01%)             0              935,380,648 ( 0.16%)     2,999,904 ( 0.05%)          3 ( 0.00%)  /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/search/views/kmer_hash.hpp:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
 82,902,713,454 ( 3.56%)     2 ( 0.02%)     2 ( 0.03%)  14,005,829,632 ( 2.94%)    13,598,727 ( 0.13%)    13,598,721 ( 0.82%)  14,006,091,776 ( 2.39%)             0                   0           /usr/include/c++/11/bitset:q_gram_mapper<26507u>::load(std::filesystem::__cxx11::path const&)
 77,350,978,708 ( 3.32%)    32 ( 0.40%)    22 ( 0.31%)  19,735,441,658 ( 4.14%)    30,947,507 ( 0.30%)        64,783 ( 0.00%)  10,318,464,699 ( 1.76%)       629,174 ( 0.01%)         11 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc
 62,780,499,690 ( 2.70%)    15 ( 0.19%)    15 ( 0.21%)   1,926,274,406 ( 0.40%)     1,164,298 ( 0.01%)             1 ( 0.00%)     484,190,269 ( 0.08%)       999,968 ( 0.02%)          1 ( 0.00%)  /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/utility/container/dynamic_bitset.hpp:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
 55,730,203,883 ( 2.39%)   395 ( 4.88%)   312 ( 4.38%)  16,447,621,731 ( 3.45%) 1,771,499,409 (17.20%)       127,230 ( 0.01%)   9,364,061,178 ( 1.60%)     2,765,966 ( 0.05%)    597,374 ( 0.69%)  ./malloc/./malloc/malloc.c:_int_malloc
 55,707,959,395 ( 2.39%)    11 ( 0.14%)    11 ( 0.15%)   6,951,272,469 ( 1.46%)            28 ( 0.00%)            18 ( 0.00%)     109,838,358 ( 0.02%)           894 ( 0.00%)        377 ( 0.00%)  /home/zhenhao/bucket-map/bucket_map/mapper/q_gram_mapper.h:q_gram_mapper<26507u>::load(std::filesystem::__cxx11::path const&)
 48,787,933,770 ( 2.09%)     6 ( 0.07%)     6 ( 0.08%)   4,286,190,042 ( 0.90%)        26,506 ( 0.00%)             0            2,857,460,028 ( 0.49%)        26,511 ( 0.00%)          1 ( 0.00%)  /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/utility/math.hpp:unsigned long seqan3::pow<unsigned long, unsigned long>(unsigned long, unsigned long)
 44,182,669,551 ( 1.90%)     7 ( 0.09%)     7 ( 0.10%)  15,783,101,525 ( 3.31%) 2,214,118,938 (21.50%)             1 ( 0.00%)   9,061,514,589 ( 1.54%)       127,495 ( 0.00%)          1 ( 0.00%)  /usr/include/c++/11/bits/hashtable.h:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
 39,472,065,914 ( 1.69%)    14 ( 0.17%)    12 ( 0.17%)  14,353,478,472 ( 3.01%)   123,583,345 ( 1.20%)       817,793 ( 0.05%)   7,176,739,252 ( 1.22%)       791,301 ( 0.01%)         11 ( 0.00%)  ./malloc/./malloc/malloc.c:free
 25,630,109,873 ( 1.10%)     1 ( 0.01%)     1 ( 0.01%)   1,708,799,458 ( 0.36%)        56,327 ( 0.00%)         9,967 ( 0.00%)          53,014 ( 0.00%)        26,506 ( 0.00%)          0           /usr/include/c++/11/bits/stl_iterator.h:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
 24,888,683,623 ( 1.07%)     3 ( 0.04%)     3 ( 0.04%)   5,710,569,430 ( 1.20%) 2,273,384,998 (22.08%)        23,021 ( 0.00%)   3,417,227,821 ( 0.58%)             0                   0           /usr/include/c++/11/bits/hashtable_policy.h:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
 22,874,089,154 ( 0.98%) 1,235 (15.25%) 1,033 (14.51%)  11,420,038,544 ( 2.40%)    24,826,759 ( 0.24%)         1,350 ( 0.00%)      18,005,409 ( 0.00%)            83 ( 0.00%)         39 ( 0.00%)  ???:???
 21,530,217,480 ( 0.92%)    10 ( 0.12%)     8 ( 0.11%)   3,588,369,580 ( 0.75%)             0                      0            3,588,369,580 ( 0.61%)     1,025,891 ( 0.02%)          1 ( 0.00%)  ???:operator new(unsigned long)
 17,221,041,703 ( 0.74%)     5 ( 0.06%)     5 ( 0.07%)   4,285,522,924 ( 0.90%)     1,999,936 ( 0.02%)             2 ( 0.00%)   1,851,761,264 ( 0.32%)             0                   0           /usr/include/c++/11/bits/stl_iterator.h:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
 15,983,098,739 ( 0.69%)     5 ( 0.06%)     5 ( 0.07%)   3,551,799,601 ( 0.75%)            34 ( 0.00%)             2 ( 0.00%)              24 ( 0.00%)             0                   0           ???:std::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const
 13,663,717,506 ( 0.59%)     8 ( 0.10%)     8 ( 0.11%)  12,689,774,073 ( 2.66%) 1,601,505,919 (15.55%) 1,526,813,414 (91.63%)  12,495,046,652 ( 2.13%)    48,390,312 ( 0.85%)      1,876 ( 0.00%)  /home/zhenhao/bucket-map/bucket_map/mapper/q_gram_mapper.h:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
 13,416,678,208 ( 0.58%)    16 ( 0.20%)    16 ( 0.22%)   3,669,558,704 ( 0.77%)     9,015,359 ( 0.09%)        15,629 ( 0.00%)   1,239,778,828 ( 0.21%)     1,002,682 ( 0.02%)          0           /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/sequence_file/format_fastq.hpp:void seqan3::format_fastq::read_sequence_record<std::istream, seqan3::dna15, std::fpos<__mbstate_t>, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >(std::istream&, seqan3::sequence_file_input_options<seqan3::dna15> const&, std::fpos<__mbstate_t>&, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> >&)
 12,054,076,524 ( 0.52%)     6 ( 0.07%)     6 ( 0.08%)     574,003,644 ( 0.12%)             0                      0                        0                      0                   0           ???:__popcountdi2
 10,378,029,267 ( 0.45%)     4 ( 0.05%)     4 ( 0.06%)   5,189,010,905 ( 1.09%)         5,195 ( 0.00%)           131 ( 0.00%)   1,701,316,235 ( 0.29%)           869 ( 0.00%)         21 ( 0.00%)  /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/sequence_file/format_fasta.hpp:seqan3::sequence_file_input<seqan3::sequence_file_input_default_traits_dna, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2>, seqan3::type_list<seqan3::format_embl, seqan3::format_fasta, seqan3::format_fastq, seqan3::format_genbank, seqan3::format_sam> >::selected_sequence_format<seqan3::detail::sequence_file_input_format_exposer<seqan3::format_fasta> >::read_sequence_record(std::istream&, seqan3::sequence_record<seqan3::type_list<std::vector<seqan3::dna5, std::allocator<seqan3::dna5> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2> >&, std::fpos<__mbstate_t>&, seqan3::sequence_file_input_options<seqan3::dna15> const&)
  8,648,360,030 ( 0.37%)     2 ( 0.02%)     2 ( 0.03%)   1,729,674,562 ( 0.36%)         1,720 ( 0.00%)             0                    2,796 ( 0.00%)             0                   0           /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/stream/detail/fast_istreambuf_iterator.hpp:seqan3::sequence_file_input<seqan3::sequence_file_input_default_traits_dna, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2>, seqan3::type_list<seqan3::format_embl, seqan3::format_fasta, seqan3::format_fastq, seqan3::format_genbank, seqan3::format_sam> >::selected_sequence_format<seqan3::detail::sequence_file_input_format_exposer<seqan3::format_fasta> >::read_sequence_record(std::istream&, seqan3::sequence_record<seqan3::type_list<std::vector<seqan3::dna5, std::allocator<seqan3::dna5> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2> >&, std::fpos<__mbstate_t>&, seqan3::sequence_file_input_options<seqan3::dna15> const&)
  8,543,096,084 ( 0.37%)     1 ( 0.01%)     1 ( 0.01%)              21 ( 0.00%)             0                      0            5,125,868,238 ( 0.87%)             0                   0           /usr/include/c++/11/ext/new_allocator.h:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
  8,543,069,545 ( 0.37%)     0              0            3,417,227,818 ( 0.72%)             0                      0            3,417,227,818 ( 0.58%)             0                   0           /usr/include/c++/11/bits/stl_pair.h:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
  8,506,565,418 ( 0.37%)     2 ( 0.02%)     2 ( 0.03%)   3,402,625,101 ( 0.71%)            27 ( 0.00%)             5 ( 0.00%)   1,701,313,439 ( 0.29%)             0                   0           /usr/include/c++/11/bits/vector.tcc:seqan3::sequence_file_input<seqan3::sequence_file_input_default_traits_dna, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2>, seqan3::type_list<seqan3::format_embl, seqan3::format_fasta, seqan3::format_fastq, seqan3::format_genbank, seqan3::format_sam> >::selected_sequence_format<seqan3::detail::sequence_file_input_format_exposer<seqan3::format_fasta> >::read_sequence_record(std::istream&, seqan3::sequence_record<seqan3::type_list<std::vector<seqan3::dna5, std::allocator<seqan3::dna5> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2> >&, std::fpos<__mbstate_t>&, seqan3::sequence_file_input_options<seqan3::dna15> const&)
  7,930,897,548 ( 0.34%)     4 ( 0.05%)     4 ( 0.06%)   1,241,557,220 ( 0.26%)    19,026,846 ( 0.18%)     9,511,861 ( 0.57%)       6,000,000 ( 0.00%)            30 ( 0.00%)          0           /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/stream/detail/fast_istreambuf_iterator.hpp:void seqan3::format_fastq::read_sequence_record<std::istream, seqan3::dna15, std::fpos<__mbstate_t>, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >(std::istream&, seqan3::sequence_file_input_options<seqan3::dna15> const&, std::fpos<__mbstate_t>&, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> >&)
  6,836,099,070 ( 0.29%)     0              0                   26,507 ( 0.00%)             0                      0                        0                      0                   0           /usr/include/c++/11/bits/stl_uninitialized.h:iterate_through_buckets(std::filesystem::__cxx11::path const&, int, int, std::function<void (std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)>, bool)
  6,600,005,824 ( 0.28%)     8 ( 0.10%)     8 ( 0.11%)   3,000,002,640 ( 0.63%)             0                      0            1,200,001,048 ( 0.20%)             0                   0           /usr/include/c++/11/bits/vector.tcc:void seqan3::format_fastq::read_sequence_record<std::istream, seqan3::dna15, std::fpos<__mbstate_t>, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >(std::istream&, seqan3::sequence_file_input_options<seqan3::dna15> const&, std::fpos<__mbstate_t>&, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> >&)
  5,382,554,370 ( 0.23%)     0              0                        0                      0                      0                        0                      0                   0           ./malloc/./malloc/arena.c:free
  5,135,494,993 ( 0.22%)     0              0            3,418,613,796 ( 0.72%)     1,146,750 ( 0.01%)             0                2,506,356 ( 0.00%)        89,593 ( 0.00%)     71,353 ( 0.08%)  /usr/include/c++/11/tuple:bucket_locator::_locate(std::filesystem::__cxx11::path const&)
  5,126,955,021 ( 0.22%)     1 ( 0.01%)     1 ( 0.01%)   3,417,970,014 ( 0.72%)    26,741,458 ( 0.26%)    24,344,080 ( 1.46%)   1,708,985,007 ( 0.29%)    26,683,450 ( 0.47%)     65,803 ( 0.08%)  /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/alphabet/nucleotide/nucleotide_base.hpp:iterate_through_buckets(std::filesystem::__cxx11::path const&, int, int, std::function<void (std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)>, bool)
  4,835,792,052 ( 0.21%)     6 ( 0.07%)     6 ( 0.08%)   3,631,785,074 ( 0.76%)         1,186 ( 0.00%)           593 ( 0.00%)   1,204,002,234 ( 0.21%)             0                   0           /usr/include/c++/11/streambuf:void seqan3::format_fastq::read_sequence_record<std::istream, seqan3::dna15, std::fpos<__mbstate_t>, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >(std::istream&, seqan3::sequence_file_input_options<seqan3::dna15> const&, std::fpos<__mbstate_t>&, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> >&)
  4,159,712,916 ( 0.18%)     2 ( 0.02%)     2 ( 0.03%)               0                      0                      0                        0                      0                   0           /usr/include/c++/11/bits/ranges_base.h:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
  3,601,893,306 ( 0.15%)    59 ( 0.73%)    55 ( 0.77%)   3,463,081,544 ( 0.73%)    57,823,410 ( 0.56%)     4,166,733 ( 0.25%)   3,450,212,303 ( 0.59%)    57,762,980 ( 1.01%) 30,910,639 (35.71%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  3,600,003,144 ( 0.15%)     2 ( 0.02%)     2 ( 0.03%)               0                      0                      0                        0                      0                   0           /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/alphabet/quality/phred_base.hpp:void seqan3::format_fastq::read_sequence_record<std::istream, seqan3::dna15, std::fpos<__mbstate_t>, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >(std::istream&, seqan3::sequence_file_input_options<seqan3::dna15> const&, std::fpos<__mbstate_t>&, std::vector<seqan3::dna4, std::allocator<seqan3::dna4> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> >&)
  3,588,369,580 ( 0.15%)     0              0                        0                      0                      0                        0                      0                   0           ???:operator delete(void*)
  3,588,369,554 ( 0.15%)     1 ( 0.01%)     1 ( 0.01%)               0                      0                      0                        0                      0                   0           ???:operator delete(void*, unsigned long)
  3,459,351,250 ( 0.15%)     1 ( 0.01%)     1 ( 0.01%)   1,729,675,226 ( 0.36%)         1,744 ( 0.00%)            26 ( 0.00%)   1,729,670,834 ( 0.29%)         1,720 ( 0.00%)          0           /usr/include/c++/11/streambuf:seqan3::sequence_file_input<seqan3::sequence_file_input_default_traits_dna, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2>, seqan3::type_list<seqan3::format_embl, seqan3::format_fasta, seqan3::format_fastq, seqan3::format_genbank, seqan3::format_sam> >::selected_sequence_format<seqan3::detail::sequence_file_input_format_exposer<seqan3::format_fasta> >::read_sequence_record(std::istream&, seqan3::sequence_record<seqan3::type_list<std::vector<seqan3::dna5, std::allocator<seqan3::dna5> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<seqan3::phred42, std::allocator<seqan3::phred42> > >, seqan3::fields<(seqan3::field)0, (seqan3::field)1, (seqan3::field)2> >&, std::fpos<__mbstate_t>&, seqan3::sequence_file_input_options<seqan3::dna15> const&)
  3,456,020,892 ( 0.15%)     1 ( 0.01%)     1 ( 0.01%)   2,880,017,410 ( 0.60%)   364,027,931 ( 3.54%)    23,562,794 ( 1.41%)               0                      0                   0           /home/zhenhao/bucket-map/bucket_map/mapper/q_gram_mapper.h:std::_Function_handler<bool (unsigned int), distinguishability_filter<26507u>::get_filter()::{lambda(unsigned int)#1}>::_M_invoke(std::_Any_data const&, unsigned int&&)
  3,128,320,968 ( 0.13%)     6 ( 0.07%)     6 ( 0.08%)   1,146,464,959 ( 0.24%)    94,162,029 ( 0.91%)             1 ( 0.00%)     405,191,670 ( 0.07%)     1,351,387 ( 0.02%)          0           /usr/include/c++/11/bits/hashtable.h:bucket_locator::_find_offset(std::unordered_multimap<unsigned int, int, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<unsigned int const, int> > > const&, int)
  2,940,008,536 ( 0.13%)     7 ( 0.09%)     7 ( 0.10%)   1,735,013,404 ( 0.36%)       999,983 ( 0.01%)             2 ( 0.00%)     599,000,524 ( 0.10%)     1,000,110 ( 0.02%)         25 ( 0.00%)  /usr/include/c++/11/bits/std_function.h:q_gram_mapper<26507u>::query_sequence(std::vector<seqan3::dna4, std::allocator<seqan3::dna4> > const&)
  2,380,443,800 ( 0.10%)     0              0            1,785,332,850 ( 0.37%)   523,072,964 ( 5.08%)             0                        0                      0                   0           /usr/include/c++/11/bits/stl_function.h:bucket_locator::_locate(std::filesystem::__cxx11::path const&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/streambuf
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr             DLmr         Dw                     D1mw           DLmw       

-- line 195 ----------------------------------------
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /// Current locale setting.
            .          .          .                      .                .            .                      .              .          .                 locale 			_M_buf_locale;
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .             public:
            .          .          .                      .                .            .                      .              .          .                 /// Destructor deallocates no buffer space.
            .          .          .                      .                .            .                      .              .          .                 virtual
            .          .          .                      .                .            .                      .              .          .                 ~basic_streambuf()
            8 ( 0.00%) 2 ( 0.02%) 1 ( 0.01%)             2 ( 0.00%)       0            0                      4 ( 0.00%)     0          0                 { }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 // [27.5.2.2.1] locales
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Entry point for imbue().
            .          .          .                      .                .            .                      .              .          .                  *  @param  __loc  The new locale.
            .          .          .                      .                .            .                      .              .          .                  *  @return  The previous locale.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  Calls the derived imbue(__loc).
-- line 211 ----------------------------------------
-- line 237 ----------------------------------------
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Entry points for derived buffer functions.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  The public versions of @c pubfoo dispatch to the protected
            .          .          .                      .                .            .                      .              .          .                  *  derived @c foo member functions, passing the arguments (if any)
            .          .          .                      .                .            .                      .              .          .                  *  and returning the result unchanged.
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 basic_streambuf*
            .          .          .                      .                .            .                      .              .          .                 pubsetbuf(char_type* __s, streamsize __n)
            6 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             6 ( 0.00%)       3 ( 0.00%)   1 ( 0.00%)             3 ( 0.00%)     0          0                 { return this->setbuf(__s, __n); }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Alters the stream position.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __off  Offset.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __way  Value for ios_base::seekdir.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __mode Value for ios_base::openmode.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  Calls virtual seekoff function.
-- line 253 ----------------------------------------
-- line 316 ----------------------------------------
            .          .          .                      .                .            .                      .              .          .                  *  If the input read position is available, returns that character
            .          .          .                      .                .            .                      .              .          .                  *  and increments the read pointer, otherwise calls and returns
            .          .          .                      .                .            .                      .              .          .                  *  @c uflow().
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 int_type
            .          .          .                      .                .            .                      .              .          .                 sbumpc()
            .          .          .                      .                .            .                      .              .          .                 {
            .          .          .                      .                .            .                      .              .          .           	int_type __ret;
        5,908 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)             0                0            0                      0              0          0           	if (__builtin_expect(this->gptr() < this->egptr(), true))
            .          .          .                      .                .            .                      .              .          .           	  {
            .          .          .                      .                .            .                      .              .          .           	    __ret = traits_type::to_int_type(*this->gptr());
            .          .          .                      .                .            .                      .              .          .           	    this->gbump(1);
            .          .          .                      .                .            .                      .              .          .           	  }
            .          .          .                      .                .            .                      .              .          .           	else
        2,954 ( 0.00%) 5 ( 0.06%) 5 ( 0.07%)         2,954 ( 0.00%)       0            0                      0              0          0           	  __ret = this->uflow();
            .          .          .                      .                .            .                      .              .          .           	return __ret;
            .          .          .                      .                .            .                      .              .          .                 }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Getting the next character.
            .          .          .                      .                .            .                      .              .          .                  *  @return  The next character, or eof.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  If the input read position is available, returns that character,
            .          .          .                      .                .            .                      .              .          .                  *  otherwise calls and returns @c underflow().  Does not move the
            .          .          .                      .                .            .                      .              .          .                  *  read position after fetching the character.
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 int_type
            .          .          .                      .                .            .                      .              .          .                 sgetc()
            .          .          .                      .                .            .                      .              .          .                 {
            .          .          .                      .                .            .                      .              .          .           	int_type __ret;
    6,002,919 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)     4,001,927 ( 0.00%) 999,969 ( 0.01%)   0                      0              0          0           	if (__builtin_expect(this->gptr() < this->egptr(), true))
            .          .          .                      .                .            .                      .              .          .           	  __ret = traits_type::to_int_type(*this->gptr());
            .          .          .                      .                .            .                      .              .          .           	else
       10,065 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)         3,560 ( 0.00%)   2,958 ( 0.00%) 634 ( 0.00%)         2,960 ( 0.00%) 1,720 ( 0.00%) 0           	  __ret = this->underflow();
            .          .          .                      .                .            .                      .              .          .           	return __ret;
            .          .          .                      .                .            .                      .              .          .                 }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Entry point for xsgetn.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __s  A buffer area.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __n  A count.
            .          .          .                      .                .            .                      .              .          .                  *
-- line 357 ----------------------------------------
-- line 461 ----------------------------------------
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  Only called from derived constructors, and sets up all the
            .          .          .                      .                .            .                      .              .          .                  *  buffer data to zero, including the pointers described in the
            .          .          .                      .                .            .                      .              .          .                  *  basic_streambuf class description.  Note that, as a result,
            .          .          .                      .                .            .                      .              .          .                  *  - the class starts with no read nor write positions available,
            .          .          .                      .                .            .                      .              .          .                  *  - this is not an error
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 basic_streambuf()
            8 ( 0.00%) 0          0                      0                0            0                      6 ( 0.00%)     0          0                 : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
            .          .          .                      .                .            .                      .              .          .                 _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
            8 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                0            0                      4 ( 0.00%)     0          0                 _M_buf_locale(locale())
            .          .          .                      .                .            .                      .              .          .                 { }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 // [27.5.2.3.1] get area access
            .          .          .                      .                .            .                      .              .          .                 ///@{
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Access to the get area.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  These functions are only available to other protected functions,
-- line 479 ----------------------------------------
-- line 482 ----------------------------------------
            .          .          .                      .                .            .                      .              .          .                  *  - eback() returns the beginning pointer for the input sequence
            .          .          .                      .                .            .                      .              .          .                  *  - gptr() returns the next pointer for the input sequence
            .          .          .                      .                .            .                      .              .          .                  *  - egptr() returns the end pointer for the input sequence
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 char_type*
            .          .          .                      .                .            .                      .              .          .                 eback() const { return _M_in_beg; }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 char_type*
3,593,023,936 ( 0.15%) 3 ( 0.04%) 3 ( 0.04%) 3,573,245,224 ( 0.75%)      14 ( 0.00%)   5 ( 0.00%)             0              0          0                 gptr()  const { return _M_in_cur;  }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 char_type*
1,808,017,503 ( 0.08%) 0          0          1,808,016,911 ( 0.38%)       0            0                      0              0          0                 egptr() const { return _M_in_end; }
            .          .          .                      .                .            .                      .              .          .                 ///@}
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Moving the read position.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __n  The delta by which to move.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  This just advances the read position without returning any data.
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 void
2,953,462,785 ( 0.13%) 2 ( 0.02%) 2 ( 0.03%)             0                0            0          2,953,462,731 ( 0.50%)     0          0                 gbump(int __n) { _M_in_cur += __n; }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Setting the three read area pointers.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __gbeg  A pointer.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __gnext  A pointer.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __gend  A pointer.
            .          .          .                      .                .            .                      .              .          .                  *  @post  @a __gbeg == @c eback(), @a __gnext == @c gptr(), and
            .          .          .                      .                .            .                      .              .          .                  *         @a __gend == @c egptr()
-- line 511 ----------------------------------------
-- line 526 ----------------------------------------
            .          .          .                      .                .            .                      .              .          .                  *  These functions are only available to other protected functions,
            .          .          .                      .                .            .                      .              .          .                  *  including derived classes.
            .          .          .                      .                .            .                      .              .          .                  *
            .          .          .                      .                .            .                      .              .          .                  *  - pbase() returns the beginning pointer for the output sequence
            .          .          .                      .                .            .                      .              .          .                  *  - pptr() returns the next pointer for the output sequence
            .          .          .                      .                .            .                      .              .          .                  *  - epptr() returns the end pointer for the output sequence
            .          .          .                      .                .            .                      .              .          .                 */
            .          .          .                      .                .            .                      .              .          .                 char_type*
            2 ( 0.00%) 0          0                      2 ( 0.00%)       0            0                      0              0          0                 pbase() const { return _M_out_beg; }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 char_type*
            2 ( 0.00%) 0          0                      2 ( 0.00%)       0            0                      0              0          0                 pptr() const { return _M_out_cur; }
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 char_type*
            .          .          .                      .                .            .                      .              .          .                 epptr() const { return _M_out_end; }
            .          .          .                      .                .            .                      .              .          .                 ///@}
            .          .          .                      .                .            .                      .              .          .           
            .          .          .                      .                .            .                      .              .          .                 /**
            .          .          .                      .                .            .                      .              .          .                  *  @brief  Moving the write position.
            .          .          .                      .                .            .                      .              .          .                  *  @param  __n  The delta by which to move.
-- line 545 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/stream/detail/fast_istreambuf_iterator.hpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr                DLmr               Dw                  D1mw        DLmw       

-- line 55 ----------------------------------------
            .          .          .                      .                   .                  .                   .           .          .               using pointer = void;                              //!< Has no pointer type.
            .          .          .                      .                   .                  .                   .           .          .               using iterator_category = std::input_iterator_tag; //!< Pure input iterator.
            .          .          .                      .                   .                  .                   .           .          .               //!\}
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               /*!\name Constructors, destructor and assignment
            .          .          .                      .                   .                  .                   .           .          .                * \{
            .          .          .                      .                   .                  .                   .           .          .                */
            .          .          .                      .                   .                  .                   .           .          .               fast_istreambuf_iterator() noexcept = default;                                             //!< Defaulted.
    2,007,456 ( 0.00%) 0          0                  3,728 ( 0.00%)          0                  0           2,003,728 ( 0.00%)  0          0               fast_istreambuf_iterator(fast_istreambuf_iterator const &) noexcept = default;             //!< Defaulted.
    2,000,932 ( 0.00%) 0          0                      0                   0                  0           2,000,932 ( 0.00%) 30 ( 0.00%) 0               fast_istreambuf_iterator(fast_istreambuf_iterator &&) noexcept = default;                  //!< Defaulted.
            .          .          .                      .                   .                  .                   .           .          .               fast_istreambuf_iterator & operator=(fast_istreambuf_iterator const &) noexcept = default; //!< Defaulted.
            .          .          .                      .                   .                  .                   .           .          .               fast_istreambuf_iterator & operator=(fast_istreambuf_iterator &&) noexcept = default;      //!< Defaulted.
            .          .          .                      .                   .                  .                   .           .          .               ~fast_istreambuf_iterator() noexcept = default;                                            //!< Defaulted.
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               //!\brief Construct from a stream buffer.
            .          .          .                      .                   .                  .                   .           .          .               explicit fast_istreambuf_iterator(std::basic_streambuf<char_t, traits_t> & ibuf) :
    2,000,932 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)             0                   0                  0           2,000,932 ( 0.00%)  0          0                   stream_buf{reinterpret_cast<stream_buffer_exposer<char_t, traits_t> *>(&ibuf)}
            .          .          .                      .                   .                  .                   .           .          .               {
            .          .          .                      .                   .                  .                   .           .          .                   assert(stream_buf != nullptr);
            .          .          .                      .                   .                  .                   .           .          .           
    6,002,796 ( 0.00%) 0          0              4,001,864 ( 0.00%)          0                  0                   0           0          0                   if (stream_buf->gptr() == stream_buf->egptr()) // If current get area is empty,
            .          .          .                      .                   .                  .                   .           .          .                       stream_buf->underflow();                   // ensure the stream buffer has content on construction.
            .          .          .                      .                   .                  .                   .           .          .               }
            .          .          .                      .                   .                  .                   .           .          .               //!\}
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               //!\brief Cache until `raw_record.size() - 1` occurrences of `field_sep` followed by `record_end` were found.
            .          .          .                      .                   .                  .                   .           .          .               template <typename record_type>
            .          .          .                      .                   .                  .                   .           .          .                   requires std::same_as<std::ranges::range_value_t<record_type>, std::string_view>
            .          .          .                      .                   .                  .                   .           .          .               void cache_record_into(char const record_end, char const field_sep, record_type & raw_record)
-- line 83 ----------------------------------------
-- line 202 ----------------------------------------
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .                   return result;
            .          .          .                      .                   .                  .                   .           .          .               }
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               /*!\name Arithmetic operators
            .          .          .                      .                   .                  .                   .           .          .                * \{
            .          .          .                      .                   .                  .                   .           .          .                */
            .          .          .                      .                   .                  .                   .           .          .               //!\brief Advance by one and rebuffer if necessary (vtable lookup iff rebuffering).
   79,114,848 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)             0                   0                  0          39,557,424 ( 0.01%)  0          0               fast_istreambuf_iterator & operator++()
            .          .          .                      .                   .                  .                   .           .          .               {
4,722,716,891 ( 0.20%) 1 ( 0.01%) 1 ( 0.01%)    19,792,545 ( 0.00%)          0                  0                   0           0          0                   assert(stream_buf != nullptr);
            .          .          .                      .                   .                  .                   .           .          .           
8,860,388,031 ( 0.38%) 0          0          1,749,447,816 ( 0.37%)          0                  0                   0           0          0                   if ((stream_buf->gptr() + 1) == stream_buf->egptr())
            .          .          .                      .                   .                  .                   .           .          .                       stream_buf->snextc(); // move right, then underflow()
            .          .          .                      .                   .                  .                   .           .          .                   else
            .          .          .                      .                   .                  .                   .           .          .                       stream_buf->gbump(1);
            .          .          .                      .                   .                  .                   .           .          .                   return *this;
   98,893,560 ( 0.00%) 0          0             59,336,136 ( 0.01%)          0                  0                   0           0          0               }
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               //!\overload
            .          .          .                      .                   .                  .                   .           .          .               void operator++(int)
            .          .          .                      .                   .                  .                   .           .          .               {
            .          .          .                      .                   .                  .                   .           .          .                   ++(*this);
            .          .          .                      .                   .                  .                   .           .          .               }
            .          .          .                      .                   .                  .                   .           .          .               //!\}
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               //!\brief Read current value from buffer (no vtable lookup, safe if not at end).
            .          .          .                      .                   .                  .                   .           .          .               reference operator*() const
            .          .          .                      .                   .                  .                   .           .          .               {
    6,002,796 ( 0.00%) 0          0              2,000,932 ( 0.00%)          0                  0                   0           0          0                   assert(stream_buf != nullptr);
1,837,587,554 ( 0.08%) 0          0          1,219,794,505 ( 0.26%) 19,027,051 ( 0.18%) 9,511,863 ( 0.57%)          0           0          0                   return *stream_buf->gptr();
            .          .          .                      .                   .                  .                   .           .          .               }
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               /*!\name Comparison operators
            .          .          .                      .                   .                  .                   .           .          .                * \brief We define comparison only against the sentinel.
            .          .          .                      .                   .                  .                   .           .          .                * \{
            .          .          .                      .                   .                  .                   .           .          .                */
            .          .          .                      .                   .                  .                   .           .          .               //!\brief True if the read buffer is not empty; involves no vtable lookup.
            .          .          .                      .                   .                  .                   .           .          .               friend bool operator==(fast_istreambuf_iterator const & lhs, std::default_sentinel_t const &) noexcept
            .          .          .                      .                   .                  .                   .           .          .               {
1,259,346,946 ( 0.05%) 2 ( 0.02%) 2 ( 0.03%)    15,781,966 ( 0.00%)      1,720 ( 0.00%)         0                   0           0          0                   assert(lhs.stream_buf != nullptr);
            .          .          .                      .                   .                  .                   .           .          .                   // compare size of remaining buffer; since ++ always resizes if possible, safe to compare pointers here
            .          .          .                      .                   .                  .                   .           .          .                   return (lhs.stream_buf->gptr() == lhs.stream_buf->egptr());
            .          .          .                      .                   .                  .                   .           .          .               }
            .          .          .                      .                   .                  .                   .           .          .           
            .          .          .                      .                   .                  .                   .           .          .               //!\brief True if the read buffer is empty; involves no vtable lookup.
            .          .          .                      .                   .                  .                   .           .          .               friend bool operator!=(fast_istreambuf_iterator const & lhs, std::default_sentinel_t const &) noexcept
            .          .          .                      .                   .                  .                   .           .          .               {
            .          .          .                      .                   .                  .                   .           .          .                   return !(lhs == std::default_sentinel);
-- line 250 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir                      I1mr       ILmr       Dr                     D1mr                   DLmr             Dw                     D1mw       DLmw       

-- line 211 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .              *  template parameter of class template _Hashtable controls whether
             .          .          .                      .                      .                .                      .          .          .              *  nodes also store a hash code. In some cases (e.g. strings) this
             .          .          .                      .                      .                .                      .          .          .              *  may be a performance win.
             .          .          .                      .                      .                .                      .          .          .              */
             .          .          .                      .                      .                .                      .          .          .             struct _Hash_node_base
             .          .          .                      .                      .                .                      .          .          .             {
             .          .          .                      .                      .                .                      .          .          .               _Hash_node_base* _M_nxt;
             .          .          .                      .                      .                .                      .          .          .           
 1,775,899,743 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%)             0                      0                0          1,775,899,743 ( 0.30%) 0          0               _Hash_node_base() noexcept : _M_nxt() { }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
             .          .          .                      .                      .                .                      .          .          .             };
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             /**
             .          .          .                      .                      .                .                      .          .          .              *  struct _Hash_node_value_base
             .          .          .                      .                      .                .                      .          .          .              *
             .          .          .                      .                      .                .                      .          .          .              *  Node type with the value to store.
-- line 227 ----------------------------------------
-- line 274 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .              *  Primary template struct _Hash_node.
             .          .          .                      .                      .                .                      .          .          .              */
             .          .          .                      .                      .                .                      .          .          .             template<typename _Value, bool _Cache_hash_code>
             .          .          .                      .                      .                .                      .          .          .               struct _Hash_node
             .          .          .                      .                      .                .                      .          .          .               : _Hash_node_base
             .          .          .                      .                      .                .                      .          .          .               , _Hash_node_value<_Value, _Cache_hash_code>
             .          .          .                      .                      .                .                      .          .          .               {
             .          .          .                      .                      .                .                      .          .          .                 _Hash_node*
 1,775,929,519 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%)             0                      0                0                      0          0          0                 _M_next() const noexcept
 2,106,056,002 ( 0.09%) 2 ( 0.02%) 2 ( 0.03%) 2,022,430,395 ( 0.42%) 1,731,159,340 (16.81%)  23,089 ( 0.00%)    83,625,607 ( 0.01%) 7 ( 0.00%) 0                 { return static_cast<_Hash_node*>(this->_M_nxt); }
             .          .          .                      .                      .                .                      .          .          .               };
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             /// Base class for node iterators.
             .          .          .                      .                      .                .                      .          .          .             template<typename _Value, bool _Cache_hash_code>
             .          .          .                      .                      .                .                      .          .          .               struct _Node_iterator_base
             .          .          .                      .                      .                .                      .          .          .               {
             .          .          .                      .                      .                .                      .          .          .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
             .          .          .                      .                      .                .                      .          .          .           
-- line 291 ----------------------------------------
-- line 422 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .             {
             .          .          .                      .                      .                .                      .          .          .               typedef std::size_t first_argument_type;
             .          .          .                      .                      .                .                      .          .          .               typedef std::size_t second_argument_type;
             .          .          .                      .                      .                .                      .          .          .               typedef std::size_t result_type;
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               result_type
             .          .          .                      .                      .                .                      .          .          .               operator()(first_argument_type __num,
             .          .          .                      .                      .                .                      .          .          .           	       second_argument_type __den) const noexcept
11,714,436,174 ( 0.50%) 1 ( 0.01%) 1 ( 0.01%) 1,773,487,676 ( 0.37%)             7 ( 0.00%)       0                      0          0          0               { return __num % __den; }
             .          .          .                      .                      .                .                      .          .          .             };
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             /// Default ranged hash function H.  In principle it should be a
             .          .          .                      .                      .                .                      .          .          .             /// function object composed from objects of type H1 and H2 such that
             .          .          .                      .                      .                .                      .          .          .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
             .          .          .                      .                      .                .                      .          .          .             /// h1 and h2.  So instead we'll just use a tag to tell class template
             .          .          .                      .                      .                .                      .          .          .             /// hashtable to do that composition.
             .          .          .                      .                      .                .                      .          .          .             struct _Default_ranged_hash { };
-- line 438 ----------------------------------------
-- line 439 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             /// Default value for rehash policy.  Bucket size is (usually) the
             .          .          .                      .                      .                .                      .          .          .             /// smallest prime that keeps the load factor small enough.
             .          .          .                      .                      .                .                      .          .          .             struct _Prime_rehash_policy
             .          .          .                      .                      .                .                      .          .          .             {
             .          .          .                      .                      .                .                      .          .          .               using __has_load_factor = true_type;
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               _Prime_rehash_policy(float __z = 1.0) noexcept
             6 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)             0                      0                0                      6 ( 0.00%) 1 ( 0.00%) 1 ( 0.00%)      : _M_max_load_factor(__z), _M_next_resize(0) { }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               float
             .          .          .                      .                      .                .                      .          .          .               max_load_factor() const noexcept
             .          .          .                      .                      .                .                      .          .          .               { return _M_max_load_factor; }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               // Return a bucket size no smaller than n.
             .          .          .                      .                      .                .                      .          .          .               std::size_t
             .          .          .                      .                      .                .                      .          .          .               _M_next_bkt(std::size_t __n) const;
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               // Return a bucket count appropriate for n elements
             .          .          .                      .                      .                .                      .          .          .               std::size_t
             .          .          .                      .                      .                .                      .          .          .               _M_bkt_for_elements(std::size_t __n) const
            53 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)             7 ( 0.00%)             2 ( 0.00%)       0                      0          0          0               { return __builtin_ceil(__n / (double)_M_max_load_factor); }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               // __n_bkt is current bucket count, __n_elt is current element count,
             .          .          .                      .                      .                .                      .          .          .               // and __n_ins is number of elements to be inserted.  Do we need to
             .          .          .                      .                      .                .                      .          .          .               // increase bucket count?  If so, return make_pair(true, n), where n
             .          .          .                      .                      .                .                      .          .          .               // is the new bucket count.  If not, return make_pair(false, 0).
             .          .          .                      .                      .                .                      .          .          .               std::pair<bool, std::size_t>
             .          .          .                      .                      .                .                      .          .          .               _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
             .          .          .                      .                      .                .                      .          .          .           		   std::size_t __n_ins) const;
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               typedef std::size_t _State;
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               _State
             .          .          .                      .                      .                .                      .          .          .               _M_state() const
 3,417,227,819 ( 0.15%) 0          0          1,708,613,910 ( 0.36%)             0                0          1,708,613,909 ( 0.29%) 0          0               { return _M_next_resize; }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               void
             .          .          .                      .                      .                .                      .          .          .               _M_reset() noexcept
             .          .          .                      .                      .                .                      .          .          .               { _M_next_resize = 0; }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .               void
             .          .          .                      .                      .                .                      .          .          .               _M_reset(_State __state)
             .          .          .                      .                      .                .                      .          .          .               { _M_next_resize = __state; }
-- line 482 ----------------------------------------
-- line 735 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .           	__h,
             .          .          .                      .                      .                .                      .          .          .           	std::piecewise_construct,
             .          .          .                      .                      .                .                      .          .          .           	std::forward_as_tuple(std::move(__k)),
             .          .          .                      .                      .                .                      .          .          .           	std::tuple<>()
             .          .          .                      .                      .                .                      .          .          .                 };
             .          .          .                      .                      .                .                      .          .          .                 auto __pos
             .          .          .                      .                      .                .                      .          .          .           	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
             .          .          .                      .                      .                .                      .          .          .                 __node._M_node = nullptr;
   179,132,397 ( 0.01%) 0          0                      0                      0                0                      0          0          0                 return __pos->second;
             .          .          .                      .                      .                .                      .          .          .               }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
             .          .          .                      .                      .                .                      .          .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .                .                      .          .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .                .                      .          .          .               auto
             .          .          .                      .                      .                .                      .          .          .               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
             .          .          .                      .                      .                .                      .          .          .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
-- line 751 ----------------------------------------
-- line 1211 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 __hash_code
             .          .          .                      .                      .                .                      .          .          .                 _M_hash_code(const _Key& __k) const
             .          .          .                      .                      .                .                      .          .          .                 {
             .          .          .                      .                      .                .                      .          .          .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
             .          .          .                      .                      .                .                      .          .          .           	    "hash function must be invocable with an argument of key type");
   649,295,181 ( 0.03%) 0          0            629,612,152 ( 0.13%)   578,721,243 ( 5.62%) 756,350 ( 0.05%)             0          0          0           	return _M_hash()(__k);
             .          .          .                      .                      .                .                      .          .          .                 }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 template<typename _Kt>
             .          .          .                      .                      .                .                      .          .          .           	__hash_code
             .          .          .                      .                      .                .                      .          .          .           	_M_hash_code_tr(const _Kt& __k) const
             .          .          .                      .                      .                .                      .          .          .           	{
             .          .          .                      .                      .                .                      .          .          .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
             .          .          .                      .                      .                .                      .          .          .           	    "hash function must be invocable with an argument of key type");
-- line 1227 ----------------------------------------
-- line 1609 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 bool
             .          .          .                      .                      .                .                      .          .          .                 _M_equals(const _Key& __k, __hash_code __c,
             .          .          .                      .                      .                .                      .          .          .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
             .          .          .                      .                      .                .                      .          .          .                 {
             .          .          .                      .                      .                .                      .          .          .           	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
             .          .          .                      .                      .                .                      .          .          .           	  "key equality predicate must be invocable with two arguments of "
             .          .          .                      .                      .                .                      .          .          .           	  "key type");
 1,789,761,512 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%)             0                      0                0                      0          0          0           	return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
             .          .          .                      .                      .                .                      .          .          .                 }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 template<typename _Kt>
             .          .          .                      .                      .                .                      .          .          .           	bool
             .          .          .                      .                      .                .                      .          .          .           	_M_equals_tr(const _Kt& __k, __hash_code __c,
             .          .          .                      .                      .                .                      .          .          .           		     const _Hash_node_value<_Value,
             .          .          .                      .                      .                .                      .          .          .           					    __hash_cached::value>& __n) const
             .          .          .                      .                      .                .                      .          .          .           	{
-- line 1625 ----------------------------------------
-- line 1631 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .           	}
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 bool
             .          .          .                      .                      .                .                      .          .          .                 _M_node_equals(
             .          .          .                      .                      .                .                      .          .          .           	const _Hash_node_value<_Value, __hash_cached::value>& __lhn,
             .          .          .                      .                      .                .                      .          .          .           	const _Hash_node_value<_Value, __hash_cached::value>& __rhn) const
             .          .          .                      .                      .                .                      .          .          .                 {
             .          .          .                      .                      .                .                      .          .          .           	return _S_node_equals(__lhn, __rhn)
   119,420,520 ( 0.01%) 0          0             59,710,260 ( 0.01%)    58,802,825 ( 0.57%)       0                      0          0          0           	  && _M_eq()(_ExtractKey{}(__lhn._M_v()), _ExtractKey{}(__rhn._M_v()));
             .          .          .                      .                      .                .                      .          .          .                 }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 void
             .          .          .                      .                      .                .                      .          .          .                 _M_swap(_Hashtable_base& __x)
             .          .          .                      .                      .                .                      .          .          .                 {
             .          .          .                      .                      .                .                      .          .          .           	__hash_code_base::_M_swap(__x);
             .          .          .                      .                      .                .                      .          .          .           	std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
             .          .          .                      .                      .                .                      .          .          .                 }
-- line 1647 ----------------------------------------
-- line 1904 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .                 __n->~__node_type();
             .          .          .                      .                      .                .                      .          .          .                 __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
             .          .          .                      .                      .                .                      .          .          .               }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             template<typename _NodeAlloc>
             .          .          .                      .                      .                .                      .          .          .               void
             .          .          .                      .                      .                .                      .          .          .               _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
             .          .          .                      .                      .                .                      .          .          .               {
 3,555,659,168 ( 0.15%) 1 ( 0.01%) 1 ( 0.01%)             0                      0                0                      0          0          0                 while (__n)
             .          .          .                      .                      .                .                      .          .          .           	{
             .          .          .                      .                      .                .                      .          .          .           	  __node_ptr __tmp = __n;
             .          .          .                      .                      .                .                      .          .          .           	  __n = __n->_M_next();
             .          .          .                      .                      .                .                      .          .          .           	  _M_deallocate_node(__tmp);
             .          .          .                      .                      .                .                      .          .          .           	}
             .          .          .                      .                      .                .                      .          .          .               }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             template<typename _NodeAlloc>
-- line 1920 ----------------------------------------
-- line 1921 ----------------------------------------
             .          .          .                      .                      .                .                      .          .          .               auto
             .          .          .                      .                      .                .                      .          .          .               _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
             .          .          .                      .                      .                .                      .          .          .               -> __buckets_ptr
             .          .          .                      .                      .                .                      .          .          .               {
             .          .          .                      .                      .                .                      .          .          .                 __buckets_alloc_type __alloc(_M_node_allocator());
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .                 auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
             .          .          .                      .                      .                .                      .          .          .                 __buckets_ptr __p = std::__to_address(__ptr);
           100 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)             0                      0                0                     25 ( 0.00%) 0          0                 __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
             .          .          .                      .                      .                .                      .          .          .                 return __p;
             .          .          .                      .                      .                .                      .          .          .               }
             .          .          .                      .                      .                .                      .          .          .           
             .          .          .                      .                      .                .                      .          .          .             template<typename _NodeAlloc>
             .          .          .                      .                      .                .                      .          .          .               void
             .          .          .                      .                      .                .                      .          .          .               _Hashtable_alloc<_NodeAlloc>::
             .          .          .                      .                      .                .                      .          .          .               _M_deallocate_buckets(__buckets_ptr __bkts,
             .          .          .                      .                      .                .                      .          .          .           			  std::size_t __bkt_count)
-- line 1937 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ext/new_allocator.h
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                  D1mr            DLmr       Dw                     D1mw            DLmw       

-- line 103 ----------------------------------------
            .           .           .                   .               .          .                      .               .          .                 allocate(size_type __n, const void* = static_cast<const void*>(0))
            .           .           .                   .               .          .                      .               .          .                 {
            .           .           .                   .               .          .                      .               .          .           #if __cplusplus >= 201103L
            .           .           .                   .               .          .                      .               .          .           	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
            .           .           .                   .               .          .                      .               .          .           	 // 3308. std::allocator<void>().allocate(n)
            .           .           .                   .               .          .                      .               .          .           	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
            .           .           .                   .               .          .                      .               .          .           #endif
            .           .           .                   .               .          .                      .               .          .           
   10,778,189 ( 0.00%)  6 ( 0.07%)  6 ( 0.08%)          0               0          0                     10 ( 0.00%)      0          0           	if (__builtin_expect(__n > this->_M_max_size(), false))
            .           .           .                   .               .          .                      .               .          .           	  {
            .           .           .                   .               .          .                      .               .          .           	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
            .           .           .                   .               .          .                      .               .          .           	    // 3190. allocator::allocate sometimes returns too little storage
            .           .           .                   .               .          .                      .               .          .           	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
            .           .           .                   .               .          .                      .               .          .           	      std::__throw_bad_array_new_length();
           21 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          0               0          0                      0               0          0           	    std::__throw_bad_alloc();
            .           .           .                   .               .          .                      .               .          .           	  }
            .           .           .                   .               .          .                      .               .          .           
            .           .           .                   .               .          .                      .               .          .           #if __cpp_aligned_new
            .           .           .                   .               .          .                      .               .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
            .           .           .                   .               .          .                      .               .          .           	  {
            .           .           .                   .               .          .                      .               .          .           	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
            .           .           .                   .               .          .                      .               .          .           	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
            .           .           .                   .               .          .                      .               .          .           	  }
            .           .           .                   .               .          .                      .               .          .           #endif
5,465,356,797 ( 0.23%) 34 ( 0.42%) 33 ( 0.46%) 11,262,263 ( 0.00%) 80,668 ( 0.00%) 0          3,516,058,881 ( 0.60%) 60,758 ( 0.00%) 5 ( 0.00%)  	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
            .           .           .                   .               .          .                      .               .          .                 }
            .           .           .                   .               .          .                      .               .          .           
            .           .           .                   .               .          .                      .               .          .                 // __p is not permitted to be a null pointer.
            .           .           .                   .               .          .                      .               .          .                 void
            .           .           .                   .               .          .                      .               .          .                 deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
            .           .           .                   .               .          .                      .               .          .                 {
            .           .           .                   .               .          .                      .               .          .           #if __cpp_aligned_new
            .           .           .                   .               .          .                      .               .          .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
-- line 135 ----------------------------------------
-- line 137 ----------------------------------------
            .           .           .                   .               .          .                      .               .          .           	    ::operator delete(__p,
            .           .           .                   .               .          .                      .               .          .           # if __cpp_sized_deallocation
            .           .           .                   .               .          .                      .               .          .           			      __t * sizeof(_Tp),
            .           .           .                   .               .          .                      .               .          .           # endif
            .           .           .                   .               .          .                      .               .          .           			      std::align_val_t(alignof(_Tp)));
            .           .           .                   .               .          .                      .               .          .           	    return;
            .           .           .                   .               .          .                      .               .          .           	  }
            .           .           .                   .               .          .                      .               .          .           #endif
3,607,198,527 ( 0.15%)  8 ( 0.10%)  8 ( 0.11%) 12,535,507 ( 0.00%) 14,486 ( 0.00%) 1 ( 0.00%) 1,795,184,977 ( 0.31%) 14,593 ( 0.00%) 9 ( 0.00%)  	::operator delete(__p
            .           .           .                   .               .          .                      .               .          .           #if __cpp_sized_deallocation
            .           .           .                   .               .          .                      .               .          .           			  , __t * sizeof(_Tp)
            .           .           .                   .               .          .                      .               .          .           #endif
            .           .           .                   .               .          .                      .               .          .           			 );
            .           .           .                   .               .          .                      .               .          .                 }
            .           .           .                   .               .          .                      .               .          .           
            .           .           .                   .               .          .                      .               .          .           #if __cplusplus <= 201703L
            .           .           .                   .               .          .                      .               .          .                 size_type
-- line 153 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/utility/container/dynamic_bitset.hpp
--------------------------------------------------------------------------------
Ir                       I1mr        ILmr        Dr                     D1mr               DLmr       Dw                   D1mw             DLmw       

-- line 96 ----------------------------------------
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .                   ~reference_proxy_type() noexcept = default; //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .                   //!\}
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .                   //!\brief Initialise from seqan3::dynamic_bitset's underlying data and a bit position.
              .           .           .                      .                  .          .                    .                .          .                   constexpr reference_proxy_type(bitfield & internal_, size_t const pos) noexcept :
              .           .           .                      .                  .          .                    .                .          .                       internal{internal_},
 66,004,364,734 ( 2.83%)  1 ( 0.01%)  1 ( 0.01%)   520,095,424 ( 0.11%)         0          0                    0                0          0                       mask{1ULL << pos}
              .           .           .                      .                  .          .                    .                .          .                   {}
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .                   //!\brief Returns the value of the referenced bit.
              .           .           .                      .                  .          .                    .                .          .                   constexpr operator bool() const noexcept
              .           .           .                      .                  .          .                    .                .          .                   {
121,852,016,053 ( 5.23%)  4 ( 0.05%)  4 ( 0.06%)    44,000,000 ( 0.01%)         0          0                    0                0          0                       return static_cast<bool>(internal.bits & mask);
              .           .           .                      .                  .          .                    .                .          .                   }
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .                   //!\brief Returns the inverted value of the referenced bit.
              .           .           .                      .                  .          .                    .                .          .                   constexpr bool operator~() const noexcept
              .           .           .                      .                  .          .                    .                .          .                   {
              .           .           .                      .                  .          .                    .                .          .                       return !static_cast<bool>(internal.bits & mask);
              .           .           .                      .                  .          .                    .                .          .                   }
              .           .           .                      .                  .          .                    .                .          .           
-- line 118 ----------------------------------------
-- line 207 ----------------------------------------
              .           .           .                      .                  .          .                    .                .          .                * \experimentalapi{Experimental since version 3.1.}
              .           .           .                      .                  .          .                    .                .          .                */
              .           .           .                      .                  .          .                    .                .          .               using size_type = detail::min_viable_uint_t<bit_capacity>;
              .           .           .                      .                  .          .                    .                .          .               //!\}
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               /*!\name Constructors, destructor and assignment
              .           .           .                      .                  .          .                    .                .          .                * \{
              .           .           .                      .                  .          .                    .                .          .                */
              2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                  0          0                    2 ( 0.00%)       0          0               constexpr dynamic_bitset() noexcept = default;                                   //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .               constexpr dynamic_bitset(dynamic_bitset const &) noexcept = default;             //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .               constexpr dynamic_bitset(dynamic_bitset &&) noexcept = default;                  //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .               constexpr dynamic_bitset & operator=(dynamic_bitset const &) noexcept = default; //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .               constexpr dynamic_bitset & operator=(dynamic_bitset &&) noexcept = default;      //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .               ~dynamic_bitset() noexcept = default;                                            //!< Defaulted.
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               /*!\brief Construct from an `uint64_t`.
              .           .           .                      .                  .          .                    .                .          .                * \param[in] value The `uint64_t` to construct/assign from.
-- line 223 ----------------------------------------
-- line 1031 ----------------------------------------
              .           .           .                      .                  .          .                    .                .          .               }
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               /*!\brief Returns the number of set bits.
              .           .           .                      .                  .          .                    .                .          .                * \details
              .           .           .                      .                  .          .                    .                .          .                * \experimentalapi{Experimental since version 3.1.}
              .           .           .                      .                  .          .                    .                .          .                */
              .           .           .                      .                  .          .                    .                .          .               constexpr size_type count() const noexcept
              .           .           .                      .                  .          .                    .                .          .               {
    464,243,338 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)             0                  0          0          462,243,338 ( 0.08%)       0          0                   return std::popcount(data.bits);
              .           .           .                      .                  .          .                    .                .          .               }
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               /*!\brief Returns the i-th element.
              .           .           .                      .                  .          .                    .                .          .                * \param[in] i Index of the element to retrieve.
              .           .           .                      .                  .          .                    .                .          .                * \throws std::out_of_range If you access an element behind the last.
              .           .           .                      .                  .          .                    .                .          .                * \returns A reference to the value at position `i`.
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * \details
-- line 1047 ----------------------------------------
-- line 1097 ----------------------------------------
              .           .           .                      .                  .          .                    .                .          .                * Constant.
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * ### Exceptions
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * No-throw guarantee.
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * \experimentalapi{Experimental since version 3.1.}
              .           .           .                      .                  .          .                    .                .          .                */
    231,095,162 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)   231,095,162 ( 0.05%)         0          0                    0                0          0               constexpr reference operator[](size_t const i) noexcept
              .           .           .                      .                  .          .                    .                .          .               {
 67,274,223,102 ( 2.89%)  2 ( 0.02%)  2 ( 0.03%) 1,146,083,941 ( 0.24%)         0          0            4,000,000 ( 0.00%)       0          0                   assert(i < size());
              .           .           .                      .                  .          .                    .                .          .                   return {data, i};
              .           .           .                      .                  .          .                    .                .          .               }
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               //!\copydoc seqan3::dynamic_bitset::operator[]()
              .           .           .                      .                  .          .                    .                .          .               constexpr const_reference operator[](size_t const i) const noexcept
              .           .           .                      .                  .          .                    .                .          .               {
              .           .           .                      .                  .          .                    .                .          .                   assert(i < size());
              .           .           .                      .                  .          .                    .                .          .                   return data.bits & 1ULL << i;
-- line 1115 ----------------------------------------
-- line 1227 ----------------------------------------
              .           .           .                      .                  .          .                    .                .          .                * ### Exceptions
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * No-throw guarantee.
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * \experimentalapi{Experimental since version 3.1.}
              .           .           .                      .                  .          .                    .                .          .                */
              .           .           .                      .                  .          .                    .                .          .               constexpr size_type size() const noexcept
              .           .           .                      .                  .          .                    .                .          .               {
     16,000,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     5,000,000 ( 0.00%)         0          0            1,000,000 ( 0.00%)       0          0                   return data.size;
              .           .           .                      .                  .          .                    .                .          .               }
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               /*!\brief Returns the maximum number of elements the container is able to hold and resolves to `bit_capacity`.
              .           .           .                      .                  .          .                    .                .          .                * \returns The number of elements in the container.
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * \details
              .           .           .                      .                  .          .                    .                .          .                *
              .           .           .                      .                  .          .                    .                .          .                * This value typically reflects the theoretical limit on the size of the container. At runtime, the size
-- line 1243 ----------------------------------------
-- line 1717 ----------------------------------------
              .           .           .                      .                  .          .                    .                .          .                */
              .           .           .                      .                  .          .                    .                .          .               /*!\brief Performs element-wise comparison.
              .           .           .                      .                  .          .                    .                .          .                * \details
              .           .           .                      .                  .          .                    .                .          .                * \experimentalapi{Experimental since version 3.1.}
              .           .           .                      .                  .          .                    .                .          .                */
              .           .           .                      .                  .          .                    .                .          .               template <size_t cap>
              .           .           .                      .                  .          .                    .                .          .               friend constexpr bool operator==(dynamic_bitset const & lhs, dynamic_bitset<cap> const & rhs) noexcept
              .           .           .                      .                  .          .                    .                .          .               {
     98,741,844 ( 0.00%) 10 ( 0.12%) 10 ( 0.14%)    29,185,428 ( 0.01%) 1,190,805 ( 0.01%) 2 ( 0.00%)  18,132,480 ( 0.00%) 999,968 ( 0.02%) 1 ( 0.00%)          return lhs.data.size == rhs.raw_data()->size && lhs.data.bits == rhs.raw_data()->bits;
              .           .           .                      .                  .          .                    .                .          .               }
              .           .           .                      .                  .          .                    .                .          .           
              .           .           .                      .                  .          .                    .                .          .               /*!\brief Performs element-wise comparison.
              .           .           .                      .                  .          .                    .                .          .                * \details
              .           .           .                      .                  .          .                    .                .          .                * \experimentalapi{Experimental since version 3.1.}
              .           .           .                      .                  .          .                    .                .          .                */
              .           .           .                      .                  .          .                    .                .          .               template <size_t cap>
              .           .           .                      .                  .          .                    .                .          .               friend constexpr bool operator!=(dynamic_bitset const & lhs, dynamic_bitset<cap> const & rhs) noexcept
-- line 1733 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/sequence_file/format_fastq.hpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr               DLmr            Dw                   D1mw             DLmw       

-- line 87 ----------------------------------------
            .          .          .                    .                  .               .                    .                .          .               format_fastq & operator=(format_fastq const &) noexcept = default; //!< Defaulted.
            .          .          .                    .                  .               .                    .                .          .               format_fastq(format_fastq &&) noexcept = default;                  //!< Defaulted.
            .          .          .                    .                  .               .                    .                .          .               format_fastq & operator=(format_fastq &&) noexcept = default;      //!< Defaulted.
            .          .          .                    .                  .               .                    .                .          .               ~format_fastq() noexcept = default;                                //!< Defaulted.
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .               //!\}
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .               //!\brief The valid file extensions for this format; note that you can modify this value.
           18 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)           0                  0               0                    5 ( 0.00%)       0          0               static inline std::vector<std::string> file_extensions{{"fastq"}, {"fq"}};
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .           protected:
            .          .          .                    .                  .               .                    .                .          .               //!\copydoc sequence_file_input_format::read_sequence_record
            .          .          .                    .                  .               .                    .                .          .               template <typename stream_type, // constraints checked by file
            .          .          .                    .                  .               .                    .                .          .                         typename seq_legal_alph_type,
            .          .          .                    .                  .               .                    .                .          .                         typename stream_pos_type,
            .          .          .                    .                  .               .                    .                .          .                         typename seq_type, // other constraints checked inside function
            .          .          .                    .                  .               .                    .                .          .                         typename id_type,
            .          .          .                    .                  .               .                    .                .          .                         typename qual_type>
   28,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)   2,000,000 ( 0.00%)         0               0           14,000,000 ( 0.00%)   1,278 ( 0.00%) 0               void read_sequence_record(stream_type & stream,
            .          .          .                    .                  .               .                    .                .          .                                         sequence_file_input_options<seq_legal_alph_type> const & options,
            .          .          .                    .                  .               .                    .                .          .                                         stream_pos_type & position_buffer,
            .          .          .                    .                  .               .                    .                .          .                                         seq_type & sequence,
            .          .          .                    .                  .               .                    .                .          .                                         id_type & id,
            .          .          .                    .                  .               .                    .                .          .                                         qual_type & qualities)
            .          .          .                    .                  .               .                    .                .          .               {
            .          .          .                    .                  .               .                    .                .          .                   auto stream_view = detail::istreambuf(stream);
            .          .          .                    .                  .               .                    .                .          .                   auto stream_it = std::ranges::begin(stream_view);
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   // cache the begin position so we write quals to the same position as seq in seq_qual case
            .          .          .                    .                  .               .                    .                .          .                   size_t sequence_size_before = 0;
            .          .          .                    .                  .               .                    .                .          .                   size_t sequence_size_after = 0;
            .          .          .                    .                  .               .                    .                .          .                   if constexpr (!detail::decays_to_ignore_v<seq_type>)
            .          .          .                    .                  .               .                    .                .          .                       sequence_size_before = size(sequence);
    8,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)           0                  0               0            6,000,000 ( 0.00%) 999,968 ( 0.02%) 0                   position_buffer = stream.tellg();
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   /* ID */
    4,000,000 ( 0.00%) 0          0            2,000,000 ( 0.00%) 1,015,587 ( 0.01%) 15,614 ( 0.00%)           0                0          0                   if (*stream_it != '@') // [[unlikely]]
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       throw parse_error{std::string{"Expected '@' on beginning of ID line, got: "}
            .          .          .                    .                  .               .                    .                .          .                                         + detail::make_printable(*stream_it)};
            .          .          .                    .                  .               .                    .                .          .                   }
    6,000,000 ( 0.00%) 0          0                    0                  0               0            2,000,000 ( 0.00%)       0          0                   ++stream_it; // skip '@'
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .           #if SEQAN3_WORKAROUND_VIEW_PERFORMANCE // can't have nice things :'(
            .          .          .                    .                  .               .                    .                .          .                   auto e = std::ranges::end(stream_view);
            .          .          .                    .                  .               .                    .                .          .                   if constexpr (!detail::decays_to_ignore_v<id_type>)
            .          .          .                    .                  .               .                    .                .          .                   {
    4,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)   2,000,000 ( 0.00%)         0               0                    0                0          0                       if (options.truncate_ids)
            .          .          .                    .                  .               .                    .                .          .                       {
            .          .          .                    .                  .               .                    .                .          .                           for (; (stream_it != e) && (!(is_cntrl || is_blank))(*stream_it); ++stream_it)
            .          .          .                    .                  .               .                    .                .          .                           {
            .          .          .                    .                  .               .                    .                .          .                               if constexpr (builtin_character<std::ranges::range_value_t<id_type>>)
            .          .          .                    .                  .               .                    .                .          .                                   id.push_back(*stream_it);
            .          .          .                    .                  .               .                    .                .          .                               else
            .          .          .                    .                  .               .                    .                .          .                                   id.push_back(assign_char_to(*stream_it, std::ranges::range_value_t<id_type>{}));
            .          .          .                    .                  .               .                    .                .          .                           }
            .          .          .                    .                  .               .                    .                .          .                           for (; (stream_it != e) && (!is_char<'\n'>)(*stream_it); ++stream_it)
            .          .          .                    .                  .               .                    .                .          .                           {}
            .          .          .                    .                  .               .                    .                .          .                       }
            .          .          .                    .                  .               .                    .                .          .                       else
            .          .          .                    .                  .               .                    .                .          .                       {
   78,666,680 ( 0.00%) 0          0           27,555,560 ( 0.01%) 1,999,938 ( 0.02%)      4 ( 0.00%)  11,777,780 ( 0.00%)       0          0                           for (; (stream_it != e) && (!is_char<'\n'>)(*stream_it); ++stream_it)
            .          .          .                    .                  .               .                    .                .          .                           {
            .          .          .                    .                  .               .                    .                .          .                               if constexpr (builtin_character<std::ranges::range_value_t<id_type>>)
            .          .          .                    .                  .               .                    .                .          .                                   id.push_back(*stream_it);
            .          .          .                    .                  .               .                    .                .          .                               else
            .          .          .                    .                  .               .                    .                .          .                                   id.push_back(assign_char_to(*stream_it, std::ranges::range_value_t<id_type>{}));
            .          .          .                    .                  .               .                    .                .          .                           }
            .          .          .                    .                  .               .                    .                .          .                       }
            .          .          .                    .                  .               .                    .                .          .                   }
-- line 156 ----------------------------------------
-- line 159 ----------------------------------------
            .          .          .                    .                  .               .                    .                .          .                       for (; (stream_it != e) && (!is_char<'\n'>)(*stream_it); ++stream_it)
            .          .          .                    .                  .               .                    .                .          .                       {}
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   if (stream_it == e)
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       throw unexpected_end_of_input{"Expected end of ID-line, got end-of-file."};
            .          .          .                    .                  .               .                    .                .          .                   }
    4,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)           0                  0               0            2,000,000 ( 0.00%)       0          0                   ++stream_it; // skip newline
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   /* Sequence */
            .          .          .                    .                  .               .                    .                .          .                   if constexpr (!detail::decays_to_ignore_v<seq_type>)
            .          .          .                    .                  .               .                    .                .          .                   {
2,416,002,096 ( 0.10%) 2 ( 0.02%) 2 ( 0.03%) 604,000,524 ( 0.13%) 1,999,958 ( 0.02%)      4 ( 0.00%)           0                0          0                       for (; (stream_it != e) && (!is_char<'+'>)(*stream_it); ++stream_it)
            .          .          .                    .                  .               .                    .                .          .                       {
1,204,001,048 ( 0.05%) 0          0          602,000,524 ( 0.13%) 1,999,938 ( 0.02%)      4 ( 0.00%)           0                0          0                           if ((!is_space)(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                           {
            .          .          .                    .                  .               .                    .                .          .                               if constexpr (builtin_character<std::ranges::range_value_t<seq_type>>)
            .          .          .                    .                  .               .                    .                .          .                               {
            .          .          .                    .                  .               .                    .                .          .                                   sequence.push_back(*stream_it);
            .          .          .                    .                  .               .                    .                .          .                               }
            .          .          .                    .                  .               .                    .                .          .                               else
            .          .          .                    .                  .               .                    .                .          .                               {
1,800,001,572 ( 0.08%) 0          0          600,000,524 ( 0.13%)   999,969 ( 0.01%)      1 ( 0.00%)           0                0          0                                   if (!char_is_valid_for<seq_legal_alph_type>(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                                   {
            .          .          .                    .                  .               .                    .                .          .                                       throw parse_error{std::string{"Encountered bad letter for seq: "}
            .          .          .                    .                  .               .                    .                .          .                                                         + detail::make_printable(*stream_it)};
            .          .          .                    .                  .               .                    .                .          .                                   }
1,800,001,572 ( 0.08%) 0          0          600,000,524 ( 0.13%)   999,969 ( 0.01%)      2 ( 0.00%) 600,000,524 ( 0.10%)   1,436 ( 0.00%) 0                                   sequence.push_back(assign_char_to(*stream_it, std::ranges::range_value_t<seq_type>{}));
            .          .          .                    .                  .               .                    .                .          .                               }
            .          .          .                    .                  .               .                    .                .          .                           }
            .          .          .                    .                  .               .                    .                .          .                       }
            .          .          .                    .                  .               .                    .                .          .                       sequence_size_after = size(sequence);
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .                   else // consume, but count
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       for (; (stream_it != e) && (!is_char<'+'>)(*stream_it); ++stream_it)
-- line 195 ----------------------------------------
-- line 196 ----------------------------------------
            .          .          .                    .                  .               .                    .                .          .                           if ((!is_space)(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                               ++sequence_size_after;
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   /* 2nd ID line */
            .          .          .                    .                  .               .                    .                .          .                   if (stream_it == e)
            .          .          .                    .                  .               .                    .                .          .                       throw unexpected_end_of_input{"Expected second ID-line, got end-of-file."};
            .          .          .                    .                  .               .                    .                .          .           
    4,000,000 ( 0.00%) 0          0                    0                  0               0                    0                0          0                   if (*stream_it != '+')
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       throw parse_error{std::string{"Expected '+' on beginning of 2nd ID line, got: "}
            .          .          .                    .                  .               .                    .                .          .                                         + detail::make_printable(*stream_it)};
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .           
   16,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)   4,000,000 ( 0.00%)         0               0                    0                0          0                   for (; (stream_it != e) && (!is_char<'\n'>)(*stream_it); ++stream_it)
            .          .          .                    .                  .               .                    .                .          .                   {}
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   if (stream_it == e)
            .          .          .                    .                  .               .                    .                .          .                       throw unexpected_end_of_input{"Expected end of second ID-line, got end-of-file."};
            .          .          .                    .                  .               .                    .                .          .           
    4,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)           0                  0               0            2,000,000 ( 0.00%)       0          0                   ++stream_it;
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   /* Qualities */
            .          .          .                    .                  .               .                    .                .          .                   if constexpr (!detail::decays_to_ignore_v<qual_type>)
            .          .          .                    .                  .               .                    .                .          .                   {
1,206,001,048 ( 0.05%) 2 ( 0.02%) 2 ( 0.03%) 604,000,524 ( 0.13%)         0               0                    0                0          0                       while (sequence_size_after > sequence_size_before)
            .          .          .                    .                  .               .                    .                .          .                       {
1,200,001,048 ( 0.05%) 0          0                    0                  0               0                    0                0          0                           if (stream_it == e)
            .          .          .                    .                  .               .                    .                .          .                               throw unexpected_end_of_input{"Expected qualities, got end-of-file."};
            .          .          .                    .                  .               .                    .                .          .           
1,200,001,048 ( 0.05%) 0          0          600,000,524 ( 0.13%)         0               0                    0                0          0                           if ((!is_space)(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                           {
  600,000,524 ( 0.03%) 0          0                    0                  0               0                    0                0          0                               --sequence_size_after;
            .          .          .                    .                  .               .                    .                .          .                               if constexpr (builtin_character<std::ranges::range_value_t<qual_type>>)
            .          .          .                    .                  .               .                    .                .          .                               {
            .          .          .                    .                  .               .                    .                .          .                                   qualities.push_back(*stream_it);
            .          .          .                    .                  .               .                    .                .          .                               }
            .          .          .                    .                  .               .                    .                .          .                               else
            .          .          .                    .                  .               .                    .                .          .                               {
1,200,001,048 ( 0.05%) 0          0                    0                  0               0                    0                0          0                                   if (!char_is_valid_for<std::ranges::range_value_t<qual_type>>(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                                   {
            .          .          .                    .                  .               .                    .                .          .                                       throw parse_error{std::string{"Encountered bad letter for qual: "}
            .          .          .                    .                  .               .                    .                .          .                                                         + detail::make_printable(*stream_it)};
            .          .          .                    .                  .               .                    .                .          .                                   }
  600,000,524 ( 0.03%) 0          0                    0                  0               0          600,000,524 ( 0.10%)       0          0                                   qualities.push_back(assign_char_to(*stream_it, std::ranges::range_value_t<qual_type>{}));
            .          .          .                    .                  .               .                    .                .          .                               }
            .          .          .                    .                  .               .                    .                .          .                           }
            .          .          .                    .                  .               .                    .                .          .                           ++stream_it;
            .          .          .                    .                  .               .                    .                .          .                       }
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .                   else // consume
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       while (sequence_size_after > sequence_size_before)
-- line 248 ----------------------------------------
-- line 251 ----------------------------------------
            .          .          .                    .                  .               .                    .                .          .                               throw unexpected_end_of_input{"File ended before expected number of qualities could be read."};
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                           if ((!is_space)(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                               --sequence_size_after;
            .          .          .                    .                  .               .                    .                .          .                           ++stream_it;
            .          .          .                    .                  .               .                    .                .          .                       }
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .           
    4,000,000 ( 0.00%) 0          0            2,000,000 ( 0.00%)         0               0                    0                0          0                   if (stream_it != e)
            .          .          .                    .                  .               .                    .                .          .                   {
    4,000,000 ( 0.00%) 0          0            2,000,000 ( 0.00%)         0               0                    0                0          0                       if ((!is_char<'\n'>)(*stream_it))
            .          .          .                    .                  .               .                    .                .          .                           throw parse_error{"Qualitites longer than sequence."};
            .          .          .                    .                  .               .                    .                .          .                       else
    4,000,000 ( 0.00%) 0          0                    0                  0               0            2,000,000 ( 0.00%)       0          0                           ++stream_it;
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .           #else //  WORKAROUND | ORIGINAL 
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .                   if constexpr (!detail::decays_to_ignore_v<id_type>)
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       if (options.truncate_ids)
            .          .          .                    .                  .               .                    .                .          .                       {
-- line 272 ----------------------------------------
-- line 332 ----------------------------------------
            .          .          .                    .                  .               .                    .                .          .                       std::ranges::copy(qview | views::char_to<std::ranges::range_value_t<qual_type>>,
            .          .          .                    .                  .               .                    .                .          .                                         std::back_inserter(qualities));
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .                   else
            .          .          .                    .                  .               .                    .                .          .                   {
            .          .          .                    .                  .               .                    .                .          .                       detail::consume(qview);
            .          .          .                    .                  .               .                    .                .          .                   }
            .          .          .                    .                  .               .                    .                .          .           #endif
   22,000,000 ( 0.00%) 0          0           18,000,000 ( 0.00%)         0               0                    0                0          0               }
            .          .          .                    .                  .               .                    .                .          .           
            .          .          .                    .                  .               .                    .                .          .               //!\copydoc sequence_file_output_format::write_sequence_record
            .          .          .                    .                  .               .                    .                .          .               template <typename stream_type, // constraints checked by file
            .          .          .                    .                  .               .                    .                .          .                         typename seq_type,    // other constraints checked inside function
            .          .          .                    .                  .               .                    .                .          .                         typename id_type,
            .          .          .                    .                  .               .                    .                .          .                         typename qual_type>
            .          .          .                    .                  .               .                    .                .          .               void write_sequence_record(stream_type & stream,
            .          .          .                    .                  .               .                    .                .          .                                          sequence_file_output_options const & options,
-- line 348 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/bucket_map/mapper/q_gram_mapper.h
--------------------------------------------------------------------------------
Ir                      I1mr       ILmr       Dr                      D1mr                   DLmr                   Dw                      D1mw                DLmw           

-- line 32 ----------------------------------------
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<std::bitset<NUM_BUCKETS>> filters;
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<int> _set_bits(int index) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Find all set bits in filters[index]
             .          .          .                       .                      .                      .                       .                   .              .                    * @param index indicates which filter we want to check.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   std::vector<int> res;
     5,269,708 ( 0.00%) 0          0               2,634,854 ( 0.00%)             0                      0                 544,962 ( 0.00%)          0              0                   if (index >= num_fault_tolerance || index < 0) {
             .          .          .                       .                      .                      .                       .                   .              .                       seqan3::debug_stream << "[ERROR]\t\t" << "The input index "
             .          .          .                       .                      .                      .                       .                   .              .                                            << index << " exceeds the fault tolerance level." << '\n';
             .          .          .                       .                      .                      .                       .                   .              .                       return res;
             .          .          .                       .                      .                      .                       .                   .              .                   } else if (filters[index].none()) {
             .          .          .                       .                      .                      .                       .                   .              .                       return res;
             .          .          .                       .                      .                      .                       .                   .              .                   }
     5,703,534 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              0                      0                      0               1,901,178 ( 0.00%)          0              0                   for (int i = filters[index]._Find_first(); i < NUM_BUCKETS; i = filters[index]._Find_next(i)) {
             .          .          .                       .                      .                      .                       .                   .              .                       res.push_back(i);
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   return res;
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           public:
             1 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0               fault_tolerate_filter(unsigned int fault, unsigned int num_buckets) {
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   num_fault_tolerance = fault;
           857 ( 0.00%) 0          0                     836 ( 0.00%)             0                      0                     830 ( 0.00%)        103 ( 0.00%)   102 ( 0.00%)          for (int i = 0; i < num_fault_tolerance; i++) {
             .          .          .                       .                      .                      .                       .                   .              .                       std::bitset<NUM_BUCKETS> filter;
             .          .          .                       .                      .                      .                       .                   .              .                       filter.set();
             .          .          .                       .                      .                      .                       .                   .              .                       filters.push_back(filter);
             .          .          .                       .                      .                      .                       .                   .              .                   }
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   allowed_max_candidate_buckets = num_buckets;
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               void reset() {
    29,999,040 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)      3,999,872 ( 0.00%)       731,499 ( 0.01%)             1 ( 0.00%)      1,999,936 ( 0.00%)          0              0                   for (int i = 0; i < num_fault_tolerance; i++) {
             .          .          .                       .                      .                      .                       .                   .              .                       filters[i].set();
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               void read(std::bitset<NUM_BUCKETS> input) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Read a set of bits and filter out the indices at which they are 0.
             .          .          .                       .                      .                      .                       .                   .              .                    * @param input a bitset with size NUM_BUCKETS indicating whether a certain k-mer appear
             .          .          .                       .                      .                      .                       .                   .              .                    *              in each bucket. (0 at position i indicates that the k-mer doesn't exist 
             .          .          .                       .                      .                      .                       .                   .              .                    *              in bucket i)
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   // Record how many time we see a 0 for each bucket
13,169,578,560 ( 0.57%) 0          0          12,539,598,720 ( 2.63%) 1,582,268,162 (15.37%) 1,526,813,413 (91.63%) 12,449,601,600 ( 2.12%) 48,040,780 ( 0.84%) 1,874 ( 0.00%)          for(unsigned int i = 0; i < num_fault_tolerance - 1; i++) {
             .          .          .                       .                      .                      .                       .                   .              .                       filters[i] &= (filters[i+1] | input);
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   // Modify filters[size-1]
             .          .          .                       .                      .                      .                       .                   .              .                   filters[num_fault_tolerance - 1] &= input;
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<int> best_results() {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Return the buckets that contains the most number of k-mers.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   std::vector<int> res;
     6,180,804 ( 0.00%) 0          0               1,545,201 ( 0.00%)             0                      0                       0                   0              0                   for (int i = num_fault_tolerance-1; i >= 0; i--) {
             .          .          .                       .                      .                      .                       .                   .              .                       res = _set_bits(i);
     1,999,394 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                       if (!res.empty()) {
             .          .          .                       .                      .                      .                       .                   .              .                           return res;
             .          .          .                       .                      .                      .                       .                   .              .                       }
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   return res;
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<int> ok_results() {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
-- line 100 ----------------------------------------
-- line 141 ----------------------------------------
             .          .          .                       .                      .                      .                       .                   .              .           public:
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<unsigned int> zeros;
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               distinguishability_filter(float distinguishability) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Initializer of the filter.
             .          .          .                       .                      .                      .                       .                   .              .                    * @param distinguishability the percentage of zeros in the bitset for each Q-gram.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   threshold = (unsigned int) (distinguishability * NUM_BUCKETS);
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               void read(const std::vector<std::bitset<NUM_BUCKETS>>& q_grams_index) {
             .          .          .                       .                      .                      .                       .                   .              .                   int valid_q_grams = 0;
     1,572,864 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        262,144 ( 0.00%)             6 ( 0.00%)             5 ( 0.00%)              0                   0              0                   for (auto &i: q_grams_index) {
             .          .          .                       .                      .                      .                       .                   .              .                       unsigned int ones = i.count();
       524,289 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                       if (NUM_BUCKETS - ones > threshold) {
       786,432 ( 0.00%) 0          0                 786,432 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              0                   0              0                           valid_q_grams++;
             .          .          .                       .                      .                      .                       .                   .              .                       }
       524,288 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                       if (ones == 0) {
             .          .          .                       .                      .                      .                       .                   .              .                           // the q-gram doesn't appear at all
             2 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                           zeros.push_back(NUM_BUCKETS);
             .          .          .                       .                      .                      .                       .                   .              .                       } else {
       262,144 ( 0.00%) 0          0                       0                      0                      0                 262,144 ( 0.00%)          7 ( 0.00%)     5 ( 0.00%)                  zeros.push_back(NUM_BUCKETS - ones);
             .          .          .                       .                      .                      .                       .                   .              .                       }
             .          .          .                       .                      .                      .                       .                   .              .                   }
             5 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              3 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              0                   0              0                   seqan3::debug_stream << "[BENCHMARK]\t" << "Number of Q-grams with distinguishability >= " << ((float) threshold) / NUM_BUCKETS << ": " 
             8 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              1 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              0                   0              0                                        << valid_q_grams << " (" << ((float) valid_q_grams) / q_grams_index.size() * 100 << "%).\n";
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::function<bool(unsigned int)> get_filter() {
   576,003,482 ( 0.02%) 0          0             576,003,482 ( 0.12%)             0                      0                       0                   0              0                   return [&](unsigned int kmer_hash) {
 2,880,017,410 ( 0.12%) 1 ( 0.01%) 1 ( 0.01%)  2,304,013,928 ( 0.48%)   364,027,931 ( 3.54%)    23,562,794 ( 1.41%)              0                   0              0                       return zeros[kmer_hash] >= threshold;
             .          .          .                       .                      .                      .                       .                   .              .                   };
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           };
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           template<unsigned int NUM_BUCKETS>
-- line 180 ----------------------------------------
-- line 206 ----------------------------------------
             .          .          .                       .                      .                      .                       .                   .              .               // sampling k-mers
             .          .          .                       .                      .                      .                       .                   .              .               Sampler* sampler;
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::bitset<NUM_BUCKETS> _bitset_from_bytes(const std::vector<unsigned char>& buf) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Convert 8-byte chars to bitset.
             .          .          .                       .                      .                      .                       .                   .              .                    * Adopted from https://stackoverflow.com/a/7463972.
             .          .          .                       .                      .                      .                       .                   .              .                    */
       524,288 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                   assert(buf.size() == ((NUM_BUCKETS + 7) >> 3));
   109,838,336 ( 0.00%) 0          0                 262,144 ( 0.00%)             0                      0             108,789,760 ( 0.02%)        886 ( 0.00%)   371 ( 0.00%)          std::bitset<NUM_BUCKETS> result;
20,845,953,024 ( 0.90%) 0          0                       0                      0                      0                       0                   0              0                   for (unsigned int j = 0; j < NUM_BUCKETS; j++)
34,743,255,040 ( 1.49%) 1 ( 0.01%) 1 ( 0.01%)  6,948,651,008 ( 1.46%)             0                      0                       0                   0              0                       result[j] = ((buf.at(j>>3) >> (j & 7)) & 1);
             .          .          .                       .                      .                      .                       .                   .              .                   return result;
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               struct _dna4_traits : seqan3::sequence_file_input_default_traits_dna {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Syntax for reading the query file.
             .          .          .                       .                      .                      .                       .                   .              .                    * 
             .          .          .                       .                      .                      .                       .                   .              .                    */
-- line 225 ----------------------------------------
-- line 228 ----------------------------------------
             .          .          .                       .                      .                      .                       .                   .              .                   template <typename alph>
             .          .          .                       .                      .                      .                       .                   .              .                   using sequence_container = std::vector<alph>; // must be defined as a template!
             .          .          .                       .                      .                      .                       .                   .              .               };
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           public:
             .          .          .                       .                      .                      .                       .                   .              .               q_gram_mapper(unsigned int bucket_len, unsigned int read_len, seqan3::shape shape, 
             .          .          .                       .                      .                      .                       .                   .              .                             unsigned int samples, unsigned int fault, float distinguishability, 
             2 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              0                      0                      0                       1 ( 0.00%)          1 ( 0.00%)     0                             unsigned int num_candidate_buckets = 30) : mapper() {
             .          .          .                       .                      .                      .                       .                   .              .                   // initialize private variables
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   bucket_length = bucket_len;
             .          .          .                       .                      .                      .                       .                   .              .                   read_length = read_len;
             .          .          .                       .                      .                      .                       .                   .              .                   
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          1 ( 0.00%)     0                   q_gram_shape = shape;
             .          .          .                       .                      .                      .                       .                   .              .                   size = std::ranges::size(shape);
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   q = shape.count();
             .          .          .                       .                      .                      .                       .                   .              .                   
             2 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              1 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              1 ( 0.00%)          0              0                   num_samples = samples;
             .          .          .                       .                      .                      .                       .                   .              .                   num_fault_tolerance = fault;
             1 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   allowed_max_candidate_buckets = num_candidate_buckets;
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   // initialize filter
             5 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              1 ( 0.00%)             0                      0                       2 ( 0.00%)          1 ( 0.00%)     0                   filter = new fault_tolerate_filter<NUM_BUCKETS>(num_fault_tolerance, num_candidate_buckets);
             3 ( 0.00%) 0          0                       0                      0                      0                       2 ( 0.00%)          0              0                   dist_filter = new distinguishability_filter<NUM_BUCKETS>(distinguishability);
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   // Initialize sampler
             3 ( 0.00%) 0          0                       0                      0                      0                       2 ( 0.00%)          0              0                   sampler = new Sampler(num_samples);
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
             5 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)              0                      0                      0                       2 ( 0.00%)          0              0               ~q_gram_mapper() {
             6 ( 0.00%) 0          0                       1 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              1 ( 0.00%)          0              0                   delete filter;
             6 ( 0.00%) 0          0                       1 ( 0.00%)             0                      0                       1 ( 0.00%)          0              0                   delete dist_filter;
             6 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              1 ( 0.00%)             0                      0                       1 ( 0.00%)          0              0                   delete sampler;
             6 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              3 ( 0.00%)             0                      0                       1 ( 0.00%)          1 ( 0.00%)     1 ( 0.00%)      }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             9 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)              0                      0                      0                       7 ( 0.00%)          1 ( 0.00%)     1 ( 0.00%)      void load(std::filesystem::path const & index_directory) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Look for index and pattern file inside the index_directory,
             .          .          .                       .                      .                      .                       .                   .              .                    *        read the files and store the values in class attribute.
             .          .          .                       .                      .                      .                       .                   .              .                    * @param index_directory the directory that stores the q_gram_count_file.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   // q_grams_index should be empty
             5 ( 0.00%) 0          0                       3 ( 0.00%)             0                      0                       1 ( 0.00%)          0              0                   if (!q_grams_index.empty()) {
             .          .          .                       .                      .                      .                       .                   .              .                       seqan3::debug_stream << "[ERROR]\t\t" << "The q-gram index is not empty. Terminating load.\n";
             .          .          .                       .                      .                      .                       .                   .              .                       return;
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   // initialize q_gram index
             3 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                   int total_q_grams = (int) pow(4, q);
             .          .          .                       .                      .                      .                       .                   .              .                   int num_chars_per_q_gram = (NUM_BUCKETS + 7) >> 3;
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   // Read the index file
             .          .          .                       .                      .                      .                       .                   .              .                   std::ifstream file(index_directory / "index.qgram");
             4 ( 0.00%) 0          0                       1 ( 0.00%)             0                      0                       1 ( 0.00%)          0              0                   if (file) {
             .          .          .                       .                      .                      .                       .                   .              .                       Timer clock;
             .          .          .                       .                      .                      .                       .                   .              .                       clock.tick();
             .          .          .                       .                      .                      .                       .                   .              .                       // get length fo file
             4 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              0                      0                      0                       1 ( 0.00%)          0              0                       file.seekg(0, file.end);
             3 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                       int length = file.tellg();
             4 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                       file.seekg(0, file.beg);
             .          .          .                       .                      .                      .                       .                   .              .                       
             .          .          .                       .                      .                      .                       .                   .              .                       // read the file into buffer
             4 ( 0.00%) 0          0                       0                      0                      0                       2 ( 0.00%)          0              0                       char * buffer = new char[length];
             4 ( 0.00%) 0          0                       0                      0                      0                       1 ( 0.00%)          0              0                       file.read(buffer, length);
             .          .          .                       .                      .                      .                       .                   .              .                       
             .          .          .                       .                      .                      .                       .                   .              .                       // load buffer into q_grams_index
             .          .          .                       .                      .                      .                       .                   .              .                       unsigned int start_index, end_index;
     1,048,580 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        786,432 ( 0.00%)            16 ( 0.00%)             7 ( 0.00%)              2 ( 0.00%)          0              0                       for (unsigned int i = 0; i < total_q_grams; i++) {
             .          .          .                       .                      .                      .                       .                   .              .                           start_index = i * num_chars_per_q_gram;
     1,048,576 ( 0.00%) 0          0                 262,144 ( 0.00%)             0                      0                 262,144 ( 0.00%)          0              0                           end_index = (i+1) * num_chars_per_q_gram;
     1,835,008 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        262,144 ( 0.00%)             0                      0                 262,144 ( 0.00%)          0              0                           auto data = new std::vector<unsigned char>(buffer + start_index, buffer + end_index);
            19 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                           q_grams_index.push_back(_bitset_from_bytes(*data));
       786,432 ( 0.00%) 0          0                       0                      0                      0                 262,144 ( 0.00%)          0              0                           delete data;
             .          .          .                       .                      .                      .                       .                   .              .                       }
             2 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              1 ( 0.00%)             0                      0                       1 ( 0.00%)          0              0                       delete[] buffer;
             2 ( 0.00%) 0          0                       1 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              1 ( 0.00%)          0              0                       dist_filter->read(q_grams_index);
             1 ( 0.00%) 0          0                       1 ( 0.00%)             0                      0                       0                   0              0                       dist_view = dist_filter->get_filter();
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                       // Complete the read
             .          .          .                       .                      .                      .                       .                   .              .                       clock.tock();
             .          .          .                       .                      .                      .                       .                   .              .                       seqan3::debug_stream << "[BENCHMARK]\t" << "Elapsed time for loading index files: " 
             .          .          .                       .                      .                      .                       .                   .              .                                            << clock.elapsed_seconds() << " s." << '\n';
             .          .          .                       .                      .                      .                       .                   .              .                       seqan3::debug_stream << "[INFO]\t\t" << "Successfully loaded " 
             4 ( 0.00%) 0          0                       1 ( 0.00%)             0                      0                       2 ( 0.00%)          0              0                                            << index_directory / "index.qgram" << "." << '\n';
             .          .          .                       .                      .                      .                       .                   .              .                   }
            11 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              9 ( 0.00%)             2 ( 0.00%)             2 ( 0.00%)              0                   0              0               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<int> query(const std::vector<int>& q_gram_hash) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief From `q_grams_index`, determine where the sequence may be coming from.
             .          .          .                       .                      .                      .                       .                   .              .                    * @param q_gram_hash the vector containing all hash values of q-grams in the
             .          .          .                       .                      .                      .                       .                   .              .                    *                    query sequence.
             .          .          .                       .                      .                      .                       .                   .              .                    * @returns a vector of integers indicating the possible regions that the sequence
             .          .          .                       .                      .                      .                       .                   .              .                    *          may belong to.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   // q_grams_index should not be empty
     1,999,936 ( 0.00%) 0          0                 999,968 ( 0.00%)             0                      0                       0                   0              0                   if (q_grams_index.empty()) {
             .          .          .                       .                      .                      .                       .                   .              .                       seqan3::debug_stream << "[ERROR]\t\t" << "The q-gram index is empty. Cannot accept query.\n";
             .          .          .                       .                      .                      .                       .                   .              .                       std::vector<int> res;
             .          .          .                       .                      .                      .                       .                   .              .                       return res;
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   // Reset the filter
     1,999,936 ( 0.00%) 0          0                 999,968 ( 0.00%)             0                      0                 999,968 ( 0.00%)          0              0                   filter->reset();
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   // insert those samples into the filter
    91,997,056 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                   for (int h : q_gram_hash) {
    89,997,120 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)     29,999,040 ( 0.01%)    14,211,075 ( 0.14%)             0                       0                   0              0                       filter->read(q_grams_index[h]);
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   return filter->best_results();
             .          .          .                       .                      .                      .                       .                   .              .                   //return filter->all_results();
             .          .          .                       .                      .                      .                       .                   .              .                   //return filter->ok_results();
             .          .          .                       .                      .                      .                       .                   .              .               }
             .          .          .                       .                      .                      .                       .                   .              .           
    16,000,000 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)      3,000,000 ( 0.00%)         4,082 ( 0.00%)             0               9,000,000 ( 0.00%)          2 ( 0.00%)     2 ( 0.00%)      std::vector<int> query_sequence(const std::vector<seqan3::dna4>& sequence) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief From `q_grams_index`, determine where the sequence may be coming from.
             .          .          .                       .                      .                      .                       .                   .              .                    * @param sequence A dna4 vector containing the query sequence.
             .          .          .                       .                      .                      .                       .                   .              .                    * @returns a vector of integers indicating the possible regions that the sequence
             .          .          .                       .                      .                      .                       .                   .              .                    *          may belong to.
             .          .          .                       .                      .                      .                       .                   .              .                    * TODO: implement query with argument being a file containing short reads, together with quality.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   auto q_gram = seqan3::views::kmer_hash(q_gram_shape);
             .          .          .                       .                      .                      .                       .                   .              .                   auto values = sequence | q_gram | std::views::filter(dist_view);
             .          .          .                       .                      .                      .                       .                   .              .                   std::vector<unsigned int> hash_values(values.begin(), values.end());
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   // if not enough q-grams ramained to determine the exact location, simply ignore this query sequence.
    11,000,000 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)      3,000,000 ( 0.00%)     1,192,453 ( 0.01%)             0                       0                   0              0                   if (hash_values.size() < 0.2 * num_samples){
             .          .          .                       .                      .                      .                       .                   .              .                       std::vector<int> res;
             .          .          .                       .                      .                      .                       .                   .              .                       return res;
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   std::vector<int> samples;
             .          .          .                       .                      .                      .                       .                   .              .                   /*
             .          .          .                       .                      .                      .                       .                   .              .                   // Randomly sample `num_samples` q-grams for query.
             .          .          .                       .                      .                      .                       .                   .              .                   std::sample(hash_values.begin(), hash_values.end(), 
             .          .          .                       .                      .                      .                       .                   .              .                               std::back_inserter(samples), num_samples,
             .          .          .                       .                      .                      .                       .                   .              .                               std::mt19937{std::random_device{}()});
             .          .          .                       .                      .                      .                       .                   .              .                   */
             .          .          .                       .                      .                      .                       .                   .              .                   // Deterministically sample from the hash values.
     2,999,904 ( 0.00%) 0          0                 999,968 ( 0.00%)       421,208 ( 0.00%)             0                 999,968 ( 0.00%)          0              0                   sampler->sample_deterministically(hash_values.size()-1);
    94,996,960 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        999,968 ( 0.00%)             0                      0                       0                   0              0                   for (auto sample : sampler->samples) {
   119,996,160 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)     89,997,120 ( 0.02%)       677,642 ( 0.01%)             0              29,999,040 ( 0.01%)    349,530 ( 0.01%)     0                       samples.push_back(hash_values[sample]);
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   auto res = query(samples);
     1,999,394 ( 0.00%) 0          0               1,999,394 ( 0.00%)       999,697 ( 0.01%)             0                       0                   0              0                   if (res.size() > allowed_max_candidate_buckets) {
             .          .          .                       .                      .                      .                       .                   .              .                       res.clear();
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   
             .          .          .                       .                      .                      .                       .                   .              .                   return res;
             .          .          .                       .                      .                      .                       .                   .              .                   
    12,000,000 ( 0.00%) 0          0              10,000,000 ( 0.00%)     1,000,101 ( 0.01%)             0                       0                   0              0               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .           
            14 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)              1 ( 0.00%)             0                      0                       7 ( 0.00%)          0              0               std::vector<std::vector<unsigned int>> map(std::filesystem::path const & sequence_file) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Read a query fastq file and output the ids of the sequence that are mapped 
             .          .          .                       .                      .                      .                       .                   .              .                    *        to each file.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   std::vector<std::vector<unsigned int>> res;
            10 ( 0.00%) 0          0                       0                      0                      0                       3 ( 0.00%)          0              0                   seqan3::sequence_file_input<_dna4_traits> fin{sequence_file};
             .          .          .                       .                      .                      .                       .                   .              .                   // initialize returning result
        53,015 ( 0.00%) 0          0                       0                      0                      0                       0                   0              0                   for (int i = 0; i < NUM_BUCKETS; i++) {
             .          .          .                       .                      .                      .                       .                   .              .                       std::vector<unsigned int> sequence_ids;
             .          .          .                       .                      .                      .                       .                   .              .                       res.push_back(sequence_ids);
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .                   Timer clock;
             .          .          .                       .                      .                      .                       .                   .              .                   clock.tick();
     2,000,001 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        999,999 ( 0.00%)             0                      0                       0                   0              0                   for (auto & rec : fin) {
    11,924,839 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)      1,000,000 ( 0.00%)             0                      0               1,000,000 ( 0.00%)          0              0                       for (auto & bucket : query_sequence(rec.sequence())) {
     1,260,074 ( 0.00%) 0          0               1,260,071 ( 0.00%)             0                      0                       1 ( 0.00%)          0              0                           res[bucket].push_back(num_records);
             .          .          .                       .                      .                      .                       .                   .              .                       }
     1,000,000 ( 0.00%) 0          0               1,000,000 ( 0.00%)         4,897 ( 0.00%)             0                       0                   0              0                       ++num_records;
             .          .          .                       .                      .                      .                       .                   .              .                   }
             .          .          .                       .                      .                      .                       .                   .              .                   clock.tock();
             .          .          .                       .                      .                      .                       .                   .              .                   float time = clock.elapsed_seconds();
             .          .          .                       .                      .                      .                       .                   .              .                   seqan3::debug_stream << "[BENCHMARK]\t" << "Elapsed time for bucket mapping: " 
             7 ( 0.00%) 0          0                       3 ( 0.00%)             0                      0                       0                   0              0                                        << time << " s (" << time * 1000 * 1000 / num_records << " s/seq).\n";
             .          .          .                       .                      .                      .                       .                   .              .                   return res;
            12 ( 0.00%) 1 ( 0.01%) 0                       9 ( 0.00%)             1 ( 0.00%)             1 ( 0.00%)              0                   0              0               }
             .          .          .                       .                      .                      .                       .                   .              .           
             .          .          .                       .                      .                      .                       .                   .              .               std::vector<std::vector<int>> _query_file(std::filesystem::path sequence_file) {
             .          .          .                       .                      .                      .                       .                   .              .                   /**
             .          .          .                       .                      .                      .                       .                   .              .                    * * This function is just for benchmarking.
             .          .          .                       .                      .                      .                       .                   .              .                    * @brief Read a query fastq file and output the bucket ids each query belongs to.
             .          .          .                       .                      .                      .                       .                   .              .                    * TODO: include the quality information for fastq.
             .          .          .                       .                      .                      .                       .                   .              .                    */
             .          .          .                       .                      .                      .                       .                   .              .                   std::vector<std::vector<int>> res;
-- line 419 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/io/sequence_file/format_fasta.hpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr        Dw                     D1mw         DLmw        

-- line 87 ----------------------------------------
            .          .          .                      .              .           .                      .            .           .               format_fasta & operator=(format_fasta const &) noexcept = default; //!< Defaulted.
            .          .          .                      .              .           .                      .            .           .               format_fasta(format_fasta &&) noexcept = default;                  //!< Defaulted.
            .          .          .                      .              .           .                      .            .           .               format_fasta & operator=(format_fasta &&) noexcept = default;      //!< Defaulted.
            .          .          .                      .              .           .                      .            .           .               ~format_fasta() noexcept = default;                                //!< Defaulted.
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .               //!\}
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .               //!\brief The valid file extensions for this format; note that you can modify this value.
           10 ( 0.00%) 0          0                      2 ( 0.00%)     0           0                      2 ( 0.00%)   0           0               static inline std::vector<std::string> file_extensions{
            .          .          .                      .              .           .                      .            .           .                   {"fasta"},
            .          .          .                      .              .           .                      .            .           .                   {"fa"},
            .          .          .                      .              .           .                      .            .           .                   {"fna"},
            .          .          .                      .              .           .                      .            .           .                   {"ffn"},
            .          .          .                      .              .           .                      .            .           .                   {"faa"},
            .          .          .                      .              .           .                      .            .           .                   {"frn"},
            .          .          .                      .              .           .                      .            .           .                   {"fas"},
           50 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)             0              0           0                      8 ( 0.00%)   0           0               };
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .           protected:
            .          .          .                      .              .           .                      .            .           .               //!\copydoc sequence_file_input_format::read_sequence_record
            .          .          .                      .              .           .                      .            .           .               template <typename stream_type, // constraints checked by file
            .          .          .                      .              .           .                      .            .           .                         typename legal_alph_type,
            .          .          .                      .              .           .                      .            .           .                         typename stream_pos_type,
            .          .          .                      .              .           .                      .            .           .                         typename seq_type, // other constraints checked inside function
            .          .          .                      .              .           .                      .            .           .                         typename id_type,
-- line 111 ----------------------------------------
-- line 115 ----------------------------------------
            .          .          .                      .              .           .                      .            .           .                                         stream_pos_type & position_buffer,
            .          .          .                      .              .           .                      .            .           .                                         seq_type & sequence,
            .          .          .                      .              .           .                      .            .           .                                         id_type & id,
            .          .          .                      .              .           .                      .            .           .                                         qual_type & SEQAN3_DOXYGEN_ONLY(qualities))
            .          .          .                      .              .           .                      .            .           .               {
            .          .          .                      .              .           .                      .            .           .                   auto stream_view = detail::istreambuf(stream);
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                   // Store current position in buffer
        3,728 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0              0           0                  2,796 ( 0.00%) 850 ( 0.00%) 16 ( 0.00%)          position_buffer = stream.tellg();
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                   // ID
        3,728 ( 0.00%) 0          0                      0              0           0                    932 ( 0.00%)   0           0                   read_id(stream_view, options, id);
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                   // Sequence
            .          .          .                      .              .           .                      .            .           .                   read_seq(stream_view, options, sequence);
            .          .          .                      .              .           .                      .            .           .               }
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .               //!\copydoc sequence_file_output_format::write_sequence_record
            .          .          .                      .              .           .                      .            .           .               template <typename stream_type, // constraints checked by file
            .          .          .                      .              .           .                      .            .           .                         typename seq_type,    // other constraints checked inside function
-- line 134 ----------------------------------------
-- line 170 ----------------------------------------
            .          .          .                      .              .           .                      .            .           .                   }
            .          .          .                      .              .           .                      .            .           .               }
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .           private:
            .          .          .                      .              .           .                      .            .           .               //!\privatesection
            .          .          .                      .              .           .                      .            .           .               //!\brief Implementation of reading the ID.
            .          .          .                      .              .           .                      .            .           .               template <typename stream_view_t, typename seq_legal_alph_type, typename id_type>
            .          .          .                      .              .           .                      .            .           .               void
        9,320 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0              0           0                  5,592 ( 0.00%)   0           0               read_id(stream_view_t & stream_view, sequence_file_input_options<seq_legal_alph_type> const & options, id_type & id)
            .          .          .                      .              .           .                      .            .           .               {
            .          .          .                      .              .           .                      .            .           .                   auto const is_id = is_char<'>'> || is_char<';'>;
            .          .          .                      .              .           .                      .            .           .           
        1,864 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0              0           0                      0            0           0                   if (!is_id(*begin(stream_view)))
            .          .          .                      .              .           .                      .            .           .                       throw parse_error{std::string{"Expected to be on beginning of ID, but "} + is_id.msg
            .          .          .                      .              .           .                      .            .           .                                         + " evaluated to false on " + detail::make_printable(*begin(stream_view))};
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                   if constexpr (detail::decays_to_ignore_v<id_type>) // Skip the ID, it is not requested by the user.
            .          .          .                      .              .           .                      .            .           .                   {
            .          .          .                      .              .           .                      .            .           .                       detail::consume(stream_view | detail::take_line_or_throw);
            .          .          .                      .              .           .                      .            .           .                   }
            .          .          .                      .              .           .                      .            .           .                   else // read ID
            .          .          .                      .              .           .                      .            .           .                   {
        1,864 ( 0.00%) 0          0                    932 ( 0.00%)     0           0                      0            0           0                       if (options.truncate_ids)
            .          .          .                      .              .           .                      .            .           .                       {
            .          .          .                      .              .           .                      .            .           .           #if SEQAN3_WORKAROUND_VIEW_PERFORMANCE
            .          .          .                      .              .           .                      .            .           .                           auto it = stream_view.begin();
            .          .          .                      .              .           .                      .            .           .                           auto e = stream_view.end();
            .          .          .                      .              .           .                      .            .           .                           ++it; // already checked `is_id`
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                           if (options.fasta_ignore_blanks_before_id)
            .          .          .                      .              .           .                      .            .           .                           {
-- line 200 ----------------------------------------
-- line 242 ----------------------------------------
            .          .          .                      .              .           .                      .            .           .                           detail::consume(stream_view | detail::take_line_or_throw);
            .          .          .                      .              .           .                      .            .           .           #endif // SEQAN3_WORKAROUND_VIEW_PERFORMANCE
            .          .          .                      .              .           .                      .            .           .                       }
            .          .          .                      .              .           .                      .            .           .                       else // options.truncate_ids
            .          .          .                      .              .           .                      .            .           .                       {
            .          .          .                      .              .           .                      .            .           .           #if SEQAN3_WORKAROUND_VIEW_PERFORMANCE
            .          .          .                      .              .           .                      .            .           .                           auto it = stream_view.begin();
            .          .          .                      .              .           .                      .            .           .                           auto e = stream_view.end();
        1,864 ( 0.00%) 0          0                      0              0           0                    932 ( 0.00%)   0           0                           ++it; // skip leading '>' or ';'
            .          .          .                      .              .           .                      .            .           .           
        1,864 ( 0.00%) 0          0                    932 ( 0.00%)     0           0                      0            0           0                           if (options.fasta_ignore_blanks_before_id)
            .          .          .                      .              .           .                      .            .           .                           {
        3,728 ( 0.00%) 0          0                    932 ( 0.00%)   857 ( 0.00%) 17 ( 0.00%)             0            0           0                               for (; (it != e) && (is_blank)(*it); ++it) // skip leading ' '
            .          .          .                      .              .           .                      .            .           .                               {}
            .          .          .                      .              .           .                      .            .           .                           }
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                           bool at_delimiter = false;
       29,490 ( 0.00%) 0          0                      0              0           0                      0            0           0                           for (; it != e; ++it)
            .          .          .                      .              .           .                      .            .           .                           {
       29,490 ( 0.00%) 0          0                 14,745 ( 0.00%) 2,590 ( 0.00%) 51 ( 0.00%)             0            0           0                               if ((is_char<'\n'>)(*it))
            .          .          .                      .              .           .                      .            .           .                               {
            .          .          .                      .              .           .                      .            .           .                                   at_delimiter = true;
            .          .          .                      .              .           .                      .            .           .                                   break;
            .          .          .                      .              .           .                      .            .           .                               }
            .          .          .                      .              .           .                      .            .           .                               id.push_back(assign_char_to(*it, std::ranges::range_value_t<id_type>{}));
            .          .          .                      .              .           .                      .            .           .                           }
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                           if (!at_delimiter)
-- line 269 ----------------------------------------
-- line 283 ----------------------------------------
            .          .          .                      .              .           .                      .            .           .                               std::ranges::copy(stream_view | detail::take_line_or_throw // read line
            .          .          .                      .              .           .                      .            .           .                                                     | std::views::drop(1)                // skip leading '>' or ';'
            .          .          .                      .              .           .                      .            .           .                                                     | views::char_to<std::ranges::range_value_t<id_type>>,
            .          .          .                      .              .           .                      .            .           .                                                 std::back_inserter(id));
            .          .          .                      .              .           .                      .            .           .                           }
            .          .          .                      .              .           .                      .            .           .           #endif // SEQAN3_WORKAROUND_VIEW_PERFORMANCE
            .          .          .                      .              .           .                      .            .           .                       }
            .          .          .                      .              .           .                      .            .           .                   }
       10,252 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)         8,388 ( 0.00%)     0           0                      0            0           0               }
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .               //!\brief Implementation of reading the sequence.
            .          .          .                      .              .           .                      .            .           .               template <typename stream_view_t, typename seq_legal_alph_type, typename seq_type>
            .          .          .                      .              .           .                      .            .           .               void read_seq(stream_view_t & stream_view, sequence_file_input_options<seq_legal_alph_type> const &, seq_type & seq)
            .          .          .                      .              .           .                      .            .           .               {
            .          .          .                      .              .           .                      .            .           .                   constexpr auto is_id = is_char<'>'> || is_char<';'>;
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                   if constexpr (!detail::decays_to_ignore_v<seq_type>)
            .          .          .                      .              .           .                      .            .           .                   {
            .          .          .                      .              .           .                      .            .           .                       constexpr auto is_legal_alph = char_is_valid_for<seq_legal_alph_type>;
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .           #if SEQAN3_WORKAROUND_VIEW_PERFORMANCE
            .          .          .                      .              .           .                      .            .           .                       auto it = stream_view.begin();
            .          .          .                      .              .           .                      .            .           .                       auto e = stream_view.end();
            .          .          .                      .              .           .                      .            .           .           
        1,864 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)           932 ( 0.00%)     0           0                      0            0           0                       if (it == e)
            .          .          .                      .              .           .                      .            .           .                           throw unexpected_end_of_input{"No sequence information given!"};
            .          .          .                      .              .           .                      .            .           .           
3,459,343,531 ( 0.15%) 0          0          1,729,671,765 ( 0.36%) 1,733 ( 0.00%) 44 ( 0.00%)             0            0           0                       for (; (it != e) && ((!is_id)(*it)); ++it)
            .          .          .                      .              .           .                      .            .           .                       {
3,459,338,208 ( 0.15%) 0          0          1,729,669,104 ( 0.36%) 1,724 ( 0.00%) 43 ( 0.00%)             0            0           0                           if (is_legal_alph(*it))
            .          .          .                      .              .           .                      .            .           .                           {
3,402,625,014 ( 0.15%) 0          0          1,701,312,507 ( 0.36%)   873 ( 0.00%) 22 ( 0.00%) 1,701,312,507 ( 0.29%)  19 ( 0.00%)  5 ( 0.00%)                      seq.push_back(assign_char_to(*it, std::ranges::range_value_t<seq_type>{}));
            .          .          .                      .              .           .                      .            .           .                           }
   56,713,194 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)    28,356,597 ( 0.01%)   865 ( 0.00%) 22 ( 0.00%)             0            0           0                           else if ((is_space || is_digit)(*it))
            .          .          .                      .              .           .                      .            .           .                           {
            .          .          .                      .              .           .                      .            .           .                               continue;
            .          .          .                      .              .           .                      .            .           .                           }
            .          .          .                      .              .           .                      .            .           .                           else
            .          .          .                      .              .           .                      .            .           .                           {
            .          .          .                      .              .           .                      .            .           .           
            .          .          .                      .              .           .                      .            .           .                               throw parse_error{std::string{"Encountered an unexpected letter: "} + "char_is_valid_for<"
            .          .          .                      .              .           .                      .            .           .                                                 + detail::type_name_as_string<seq_legal_alph_type>
-- line 324 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/std_function.h
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr             DLmr        Dw                   D1mw             DLmw        

-- line 142 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .           	    return __source._M_access<_Functor*>();
            .           .           .                      .                .           .                    .                .           .           	}
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 private:
            .           .           .                      .                .           .                    .                .           .           	// Construct a location-invariant function object that fits within
            .           .           .                      .                .           .                    .                .           .           	// an _Any_data structure.
            .           .           .                      .                .           .                    .                .           .           	template<typename _Fn>
            .           .           .                      .                .           .                    .                .           .           	  static void
    2,000,001 ( 0.00%)  0           0              1,000,000 ( 0.00%)       0           0            1,000,001 ( 0.00%)       0           0           	  _M_create(_Any_data& __dest, _Fn&& __f, true_type)
            .           .           .                      .                .           .                    .                .           .           	  {
           12 ( 0.00%)  3 ( 0.04%)  3 ( 0.04%)             0                0           0                    6 ( 0.00%)       3 ( 0.00%)  1 ( 0.00%)  	    ::new (__dest._M_access()) _Functor(std::forward<_Fn>(__f));
            .           .           .                      .                .           .                    .                .           .           	  }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	// Construct a function object on the heap and store a pointer.
            .           .           .                      .                .           .                    .                .           .           	template<typename _Fn>
            .           .           .                      .                .           .                    .                .           .           	  static void
            .           .           .                      .                .           .                    .                .           .           	  _M_create(_Any_data& __dest, _Fn&& __f, false_type)
            .           .           .                      .                .           .                    .                .           .           	  {
            .           .           .                      .                .           .                    .                .           .           	    __dest._M_access<_Functor*>()
-- line 160 ----------------------------------------
-- line 175 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .           	  delete __victim._M_access<_Functor*>();
            .           .           .                      .                .           .                    .                .           .           	}
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 public:
            .           .           .                      .                .           .                    .                .           .           	static bool
            .           .           .                      .                .           .                    .                .           .           	_M_manager(_Any_data& __dest, const _Any_data& __source,
            .           .           .                      .                .           .                    .                .           .           		   _Manager_operation __op)
            .           .           .                      .                .           .                    .                .           .           	{
    4,000,016 ( 0.00%)  0           0                      0                0           0                    0                0           0           	  switch (__op)
            .           .           .                      .                .           .                    .                .           .           	    {
            .           .           .                      .                .           .                    .                .           .           	    case __get_type_info:
            .           .           .                      .                .           .                    .                .           .           #if __cpp_rtti
            .           .           .                      .                .           .                    .                .           .           	      __dest._M_access<const type_info*>() = &typeid(_Functor);
            .           .           .                      .                .           .                    .                .           .           #else
            .           .           .                      .                .           .                    .                .           .           	      __dest._M_access<const type_info*>() = nullptr;
            .           .           .                      .                .           .                    .                .           .           #endif
            .           .           .                      .                .           .                    .                .           .           	      break;
-- line 191 ----------------------------------------
-- line 208 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	template<typename _Fn>
            .           .           .                      .                .           .                    .                .           .           	  static void
            .           .           .                      .                .           .                    .                .           .           	  _M_init_functor(_Any_data& __functor, _Fn&& __f)
            .           .           .                      .                .           .                    .                .           .           	  noexcept(__and_<_Local_storage,
            .           .           .                      .                .           .                    .                .           .           			  is_nothrow_constructible<_Functor, _Fn>>::value)
            .           .           .                      .                .           .                    .                .           .           	  {
            .           .           .                      .                .           .                    .                .           .           	    _M_create(__functor, std::forward<_Fn>(__f), _Local_storage());
    1,000,000 ( 0.00%)  0           0                      0                0           0                    0                0           0           	  }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	template<typename _Signature>
            .           .           .                      .                .           .                    .                .           .           	  static bool
            .           .           .                      .                .           .                    .                .           .           	  _M_not_empty_function(const function<_Signature>& __f)
            .           .           .                      .                .           .                    .                .           .           	  { return static_cast<bool>(__f); }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	template<typename _Tp>
            .           .           .                      .                .           .                    .                .           .           	  static bool
-- line 224 ----------------------------------------
-- line 235 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .           	  _M_not_empty_function(const _Tp&)
            .           .           .                      .                .           .                    .                .           .           	  { return true; }
            .           .           .                      .                .           .                    .                .           .                 };
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .               _Function_base() = default;
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .               ~_Function_base()
            .           .           .                      .                .           .                    .                .           .               {
    6,000,050 ( 0.00%)  0           0              2,000,002 ( 0.00%)      15 ( 0.00%)  2 ( 0.00%)           0                0           0                 if (_M_manager)
    4,000,080 ( 0.00%)  3 ( 0.04%)  3 ( 0.04%)     1,000,000 ( 0.00%)       0           0            1,000,020 ( 0.00%)       0           0           	_M_manager(_M_functor, _M_functor, __destroy_functor);
            .           .           .                      .                .           .                    .                .           .               }
            .           .           .                      .                .           .                    .                .           .           
    1,000,024 ( 0.00%)  6 ( 0.07%)  5 ( 0.07%)     1,000,024 ( 0.00%) 999,968 ( 0.01%)  0                    0                0           0               bool _M_empty() const { return !_M_manager; }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .               using _Manager_type
            .           .           .                      .                .           .                    .                .           .                 = bool (*)(_Any_data&, const _Any_data&, _Manager_operation);
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .               _Any_data     _M_functor{};
            .           .           .                      .                .           .                    .                .           .               _Manager_type _M_manager{};
            .           .           .                      .                .           .                    .                .           .             };
            .           .           .                      .                .           .                    .                .           .           
-- line 255 ----------------------------------------
-- line 259 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .             template<typename _Res, typename _Functor, typename... _ArgTypes>
            .           .           .                      .                .           .                    .                .           .               class _Function_handler<_Res(_ArgTypes...), _Functor>
            .           .           .                      .                .           .                    .                .           .               : public _Function_base::_Base_manager<_Functor>
            .           .           .                      .                .           .                    .                .           .               {
            .           .           .                      .                .           .                    .                .           .                 using _Base = _Function_base::_Base_manager<_Functor>;
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .               public:
            .           .           .                      .                .           .                    .                .           .                 static bool
    2,000,020 ( 0.00%) 13 ( 0.16%) 13 ( 0.18%)             0                0           0                    0                0           0                 _M_manager(_Any_data& __dest, const _Any_data& __source,
            .           .           .                      .                .           .                    .                .           .           		 _Manager_operation __op)
            .           .           .                      .                .           .                    .                .           .                 {
    8,000,080 ( 0.00%)  0           0                      0                0           0                    0                0           0           	switch (__op)
            .           .           .                      .                .           .                    .                .           .           	  {
            .           .           .                      .                .           .                    .                .           .           #if __cpp_rtti
            .           .           .                      .                .           .                    .                .           .           	  case __get_type_info:
            .           .           .                      .                .           .                    .                .           .           	    __dest._M_access<const type_info*>() = &typeid(_Functor);
            .           .           .                      .                .           .                    .                .           .           	    break;
            .           .           .                      .                .           .                    .                .           .           #endif
            .           .           .                      .                .           .                    .                .           .           	  case __get_functor_ptr:
            .           .           .                      .                .           .                    .                .           .           	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
            .           .           .                      .                .           .                    .                .           .           	    break;
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	  default:
            .           .           .                      .                .           .                    .                .           .           	    _Base::_M_manager(__dest, __source, __op);
            .           .           .                      .                .           .                    .                .           .           	  }
            .           .           .                      .                .           .                    .                .           .           	return false;
    4,000,040 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     2,000,020 ( 0.00%)       0           0                    0                0           0                 }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 static _Res
  576,321,581 ( 0.02%)  7 ( 0.09%)  7 ( 0.10%)        26,507 ( 0.00%)  26,201 ( 0.00%)  0              185,549 ( 0.00%)  26,201 ( 0.00%)  0                 _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
            .           .           .                      .                .           .                    .                .           .                 {
            .           .           .                      .                .           .                    .                .           .           	return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
            .           .           .                      .                .           .                    .                .           .           				     std::forward<_ArgTypes>(__args)...);
  576,295,062 ( 0.02%)  0           0            576,242,048 ( 0.12%)  26,195 ( 0.00%)  0                    0                0           0                 }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 template<typename _Fn>
            .           .           .                      .                .           .                    .                .           .           	static constexpr bool
            .           .           .                      .                .           .                    .                .           .           	_S_nothrow_init() noexcept
            .           .           .                      .                .           .                    .                .           .           	{
            .           .           .                      .                .           .                    .                .           .           	  return __and_<typename _Base::_Local_storage,
            .           .           .                      .                .           .                    .                .           .           			is_nothrow_constructible<_Functor, _Fn>>::value;
            .           .           .                      .                .           .                    .                .           .           	}
-- line 300 ----------------------------------------
-- line 361 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 // [3.7.2.1] construct/copy/destroy
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief Default construct creates an empty function call wrapper.
            .           .           .                      .                .           .                    .                .           .                  *  @post `!(bool)*this`
            .           .           .                      .                .           .                    .                .           .                  */
            .           .           .                      .                .           .                    .                .           .                 function() noexcept
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                0           0                    3 ( 0.00%)       1 ( 0.00%)  0                 : _Function_base() { }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief Creates an empty function call wrapper.
            .           .           .                      .                .           .                    .                .           .                  *  @post @c !(bool)*this
            .           .           .                      .                .           .                    .                .           .                  */
            .           .           .                      .                .           .                    .                .           .                 function(nullptr_t) noexcept
            .           .           .                      .                .           .                    .                .           .                 : _Function_base() { }
            .           .           .                      .                .           .                    .                .           .           
-- line 377 ----------------------------------------
-- line 379 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .                  *  @brief %Function copy constructor.
            .           .           .                      .                .           .                    .                .           .                  *  @param __x A %function object with identical call signature.
            .           .           .                      .                .           .                    .                .           .                  *  @post `bool(*this) == bool(__x)`
            .           .           .                      .                .           .                    .                .           .                  *
            .           .           .                      .                .           .                    .                .           .                  *  The newly-created %function contains a copy of the target of
            .           .           .                      .                .           .                    .                .           .                  *  `__x` (if it has one).
            .           .           .                      .                .           .                    .                .           .                  */
            .           .           .                      .                .           .                    .                .           .                 function(const function& __x)
    5,000,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                0           0            3,000,000 ( 0.00%)     101 ( 0.00%)  0                 : _Function_base()
            .           .           .                      .                .           .                    .                .           .                 {
    2,000,000 ( 0.00%)  0           0                      0                0           0                    0                0           0           	if (static_cast<bool>(__x))
            .           .           .                      .                .           .                    .                .           .           	  {
    6,000,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                0           0            1,000,000 ( 0.00%)      21 ( 0.00%) 21 ( 0.00%)  	    __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
    2,000,000 ( 0.00%)  0           0              1,000,000 ( 0.00%)       0           0            1,000,000 ( 0.00%)       0           0           	    _M_invoker = __x._M_invoker;
    2,000,000 ( 0.00%)  0           0              1,000,000 ( 0.00%)       0           0            1,000,000 ( 0.00%)       0           0           	    _M_manager = __x._M_manager;
            .           .           .                      .                .           .                    .                .           .           	  }
            .           .           .                      .                .           .                    .                .           .                 }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief %Function move constructor.
            .           .           .                      .                .           .                    .                .           .                  *  @param __x A %function object rvalue with identical call signature.
            .           .           .                      .                .           .                    .                .           .                  *
            .           .           .                      .                .           .                    .                .           .                  *  The newly-created %function contains the target of `__x`
            .           .           .                      .                .           .                    .                .           .                  *  (if it has one).
            .           .           .                      .                .           .                    .                .           .                  */
            .           .           .                      .                .           .                    .                .           .                 function(function&& __x) noexcept
    7,000,042 ( 0.00%)  6 ( 0.07%)  6 ( 0.08%)             3 ( 0.00%)       0           0            6,000,021 ( 0.00%) 999,990 ( 0.02%)  4 ( 0.00%)        : _Function_base(), _M_invoker(__x._M_invoker)
            .           .           .                      .                .           .                    .                .           .                 {
    5,000,006 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                0           0                    0                0           0           	if (static_cast<bool>(__x))
            .           .           .                      .                .           .                    .                .           .           	  {
    8,000,042 ( 0.00%)  5 ( 0.06%)  5 ( 0.07%)     2,000,009 ( 0.00%)       0           0            5,000,021 ( 0.00%)       0           0           	    _M_functor = __x._M_functor;
    2,000,033 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)             0                0           0            2,000,018 ( 0.00%)       3 ( 0.00%)  0           	    _M_manager = __x._M_manager;
    4,000,008 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     1,000,000 ( 0.00%)       0           0            1,000,004 ( 0.00%)       0           0           	    __x._M_manager = nullptr;
            .           .           .                      .                .           .                    .                .           .           	    __x._M_invoker = nullptr;
            .           .           .                      .                .           .                    .                .           .           	  }
            .           .           .                      .                .           .                    .                .           .                 }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief Builds a %function that targets a copy of the incoming
            .           .           .                      .                .           .                    .                .           .                  *  function object.
            .           .           .                      .                .           .                    .                .           .                  *  @param __f A %function object that is callable with parameters of
-- line 419 ----------------------------------------
-- line 427 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .                  *
            .           .           .                      .                .           .                    .                .           .                  *  If `__f` is a non-null function pointer or an object of type
            .           .           .                      .                .           .                    .                .           .                  *  `reference_wrapper<F>`, this function will not throw.
            .           .           .                      .                .           .                    .                .           .                  */
            .           .           .                      .                .           .                    .                .           .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
            .           .           .                      .                .           .                    .                .           .                 // 2774. std::function construction vs assignment
            .           .           .                      .                .           .                    .                .           .                 template<typename _Functor,
            .           .           .                      .                .           .                    .                .           .           	       typename _Constraints = _Requires<_Callable<_Functor>>>
            1 ( 0.00%)  0           0                      1 ( 0.00%)       0           0                    0                0           0           	function(_Functor&& __f)
            .           .           .                      .                .           .                    .                .           .           	noexcept(_Handler<_Functor>::template _S_nothrow_init<_Functor>())
          108 ( 0.00%)  5 ( 0.06%)  5 ( 0.07%)             0                0           0                   65 ( 0.00%)       3 ( 0.00%)  3 ( 0.00%)  	: _Function_base()
            .           .           .                      .                .           .                    .                .           .           	{
            .           .           .                      .                .           .                    .                .           .           	  static_assert(is_copy_constructible<__decay_t<_Functor>>::value,
            .           .           .                      .                .           .                    .                .           .           	      "std::function target must be copy-constructible");
            .           .           .                      .                .           .                    .                .           .           	  static_assert(is_constructible<__decay_t<_Functor>, _Functor>::value,
            .           .           .                      .                .           .                    .                .           .           	      "std::function target must be constructible from the "
            .           .           .                      .                .           .                    .                .           .           	      "constructor argument");
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	  using _My_handler = _Handler<_Functor>;
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           	  if (_My_handler::_M_not_empty_function(__f))
            .           .           .                      .                .           .                    .                .           .           	    {
            .           .           .                      .                .           .                    .                .           .           	      _My_handler::_M_init_functor(_M_functor,
            .           .           .                      .                .           .                    .                .           .           					   std::forward<_Functor>(__f));
            .           .           .                      .                .           .                    .                .           .           	      _M_invoker = &_My_handler::_M_invoke;
            6 ( 0.00%)  0           0                      0                0           0                    1 ( 0.00%)       1 ( 0.00%)  1 ( 0.00%)  	      _M_manager = &_My_handler::_M_manager;
            .           .           .                      .                .           .                    .                .           .           	    }
            .           .           .                      .                .           .                    .                .           .           	}
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief %Function assignment operator.
            .           .           .                      .                .           .                    .                .           .                  *  @param __x A %function with identical call signature.
            .           .           .                      .                .           .                    .                .           .                  *  @post @c (bool)*this == (bool)x
            .           .           .                      .                .           .                    .                .           .                  *  @returns @c *this
-- line 460 ----------------------------------------
-- line 564 ----------------------------------------
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief Determine if the %function wrapper has a target.
            .           .           .                      .                .           .                    .                .           .                  *
            .           .           .                      .                .           .                    .                .           .                  *  @return @c true when this %function object contains a target,
            .           .           .                      .                .           .                    .                .           .                  *  or @c false when it is empty.
            .           .           .                      .                .           .                    .                .           .                  *
            .           .           .                      .                .           .                    .                .           .                  *  This function will not throw an %exception.
            .           .           .                      .                .           .                    .                .           .                  */
            1 ( 0.00%)  0           0                      1 ( 0.00%)       0           0                    0                0           0                 explicit operator bool() const noexcept
            .           .           .                      .                .           .                    .                .           .                 { return !_M_empty(); }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 // [3.7.2.4] function invocation
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief Invokes the function targeted by @c *this.
            .           .           .                      .                .           .                    .                .           .                  *  @returns the result of the target.
            .           .           .                      .                .           .                    .                .           .                  *  @throws bad_function_call when @c !(bool)*this
            .           .           .                      .                .           .                    .                .           .                  *
            .           .           .                      .                .           .                    .                .           .                  *  The function call operator invokes the target function object
            .           .           .                      .                .           .                    .                .           .                  *  stored by @c this.
            .           .           .                      .                .           .                    .                .           .                  */
            .           .           .                      .                .           .                    .                .           .                 _Res
            .           .           .                      .                .           .                    .                .           .                 operator()(_ArgTypes... __args) const
            .           .           .                      .                .           .                    .                .           .                 {
1,152,086,515 ( 0.05%)  1 ( 0.01%)  1 ( 0.01%)   576,056,496 ( 0.12%)  52,651 ( 0.00%) 16 ( 0.00%)           0                0           0           	if (_M_empty())
            .           .           .                      .                .           .                    .                .           .           	  __throw_bad_function_call();
1,734,107,645 ( 0.07%)  1 ( 0.01%)  1 ( 0.01%) 1,150,089,473 ( 0.24%)       0           0          578,027,046 ( 0.10%)       0           0           	return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
            .           .           .                      .                .           .                    .                .           .                 }
            .           .           .                      .                .           .                    .                .           .           
            .           .           .                      .                .           .                    .                .           .           #if __cpp_rtti
            .           .           .                      .                .           .                    .                .           .                 // [3.7.2.5] function target access
            .           .           .                      .                .           .                    .                .           .                 /**
            .           .           .                      .                .           .                    .                .           .                  *  @brief Determine the type of the target of this function object
            .           .           .                      .                .           .                    .                .           .                  *  wrapper.
            .           .           .                      .                .           .                    .                .           .                  *
-- line 598 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bitset
--------------------------------------------------------------------------------
Ir                       I1mr       ILmr       Dr                      D1mr                DLmr                Dw                      D1mw                 DLmw         

-- line 92 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .           #else
              .          .          .                       .                   .                   .                       .                    .            .                 _Base_bitset(unsigned long __val)
              .          .          .                       .                   .                   .                       .                    .            .                 : _M_w()
              .          .          .                       .                   .                   .                       .                    .            .                 { _M_w[0] = __val; }
              .          .          .                       .                   .                   .                       .                    .            .           #endif
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 static _GLIBCXX_CONSTEXPR size_t
              .          .          .                       .                   .                   .                       .                    .            .                 _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
 27,795,980,922 ( 1.19%) 0          0                       0                   0                   0                       0                    0            0                 { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 static _GLIBCXX_CONSTEXPR size_t
              .          .          .                       .                   .                   .                       .                    .            .                 _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 static _GLIBCXX_CONSTEXPR size_t
              .          .          .                       .                   .                   .                       .                    .            .                 _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 { return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 static _GLIBCXX_CONSTEXPR _WordT
              .          .          .                       .                   .                   .                       .                    .            .                 _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
 13,897,826,304 ( 0.60%) 1 ( 0.01%) 1 ( 0.01%)              0                   0                   0                       0                    0            0                 { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 _WordT&
              .          .          .                       .                   .                   .                       .                    .            .                 _M_getword(size_t __pos) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 { return _M_w[_S_whichword(__pos)]; }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 _GLIBCXX_CONSTEXPR _WordT
              .          .          .                       .                   .                   .                       .                    .            .                 _M_getword(size_t __pos) const _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 { return _M_w[_S_whichword(__pos)]; }
-- line 120 ----------------------------------------
-- line 131 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 _GLIBCXX_CONSTEXPR _WordT
              .          .          .                       .                   .                   .                       .                    .            .                 _M_hiword() const _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 { return _M_w[_Nw - 1]; }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 void
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_and(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 {
111,776,423,040 ( 4.80%) 0          0                       0                   0                   0                       0                    0            0           	for (size_t __i = 0; __i < _Nw; __i++)
111,986,416,320 ( 4.81%) 1 ( 0.01%) 1 ( 0.01%) 74,727,608,640 (15.68%) 12,325,131 ( 0.12%)          0          37,258,807,680 ( 6.35%)           0            0           	  _M_w[__i] &= __x._M_w[__i];
              .          .          .                       .                   .                   .                       .                    .            .                 }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 void
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_or(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 {
 62,547,998,400 ( 2.69%) 0          0                       0                   0                   0                       0                    0            0           	for (size_t __i = 0; __i < _Nw; __i++)
155,905,010,880 ( 6.69%) 1 ( 0.01%) 1 ( 0.01%) 62,398,003,200 (13.10%)          0                   0          31,199,001,600 ( 5.32%)           0            0           	  _M_w[__i] |= __x._M_w[__i];
              .          .          .                       .                   .                   .                       .                    .            .                 }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 void
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_xor(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 {
              .          .          .                       .                   .                   .                       .                    .            .           	for (size_t __i = 0; __i < _Nw; __i++)
              .          .          .                       .                   .                   .                       .                    .            .           	  _M_w[__i] ^= __x._M_w[__i];
              .          .          .                       .                   .                   .                       .                    .            .                 }
-- line 155 ----------------------------------------
-- line 166 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .           	for (size_t __i = 0; __i < _Nw; __i++)
              .          .          .                       .                   .                   .                       .                    .            .           	  _M_w[__i] = ~_M_w[__i];
              .          .          .                       .                   .                   .                       .                    .            .                 }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 void
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_set() _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 {
              .          .          .                       .                   .                   .                       .                    .            .           	for (size_t __i = 0; __i < _Nw; __i++)
  2,544,921,076 ( 0.11%) 2 ( 0.02%) 2 ( 0.03%)              0                   0                   0           2,495,922,618 ( 0.43%) 282,876,057 ( 4.96%) 311 ( 0.00%)  	  _M_w[__i] = ~static_cast<_WordT>(0);
              .          .          .                       .                   .                   .                       .                    .            .                 }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 void
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_reset() _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 bool
              .          .          .                       .                   .                   .                       .                    .            .                 _M_is_equal(const _Base_bitset<_Nw>& __x) const _GLIBCXX_NOEXCEPT
-- line 182 ----------------------------------------
-- line 197 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .           	  return _M_hiword() == (~static_cast<_WordT>(0)
              .          .          .                       .                   .                   .                       .                    .            .           				 >> (_Nw * _GLIBCXX_BITSET_BITS_PER_WORD
              .          .          .                       .                   .                   .                       .                    .            .           				     - _Nb));
              .          .          .                       .                   .                   .                       .                    .            .           	}
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 bool
              .          .          .                       .                   .                   .                       .                    .            .                 _M_is_any() const _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 {
  1,277,304,351 ( 0.05%) 0          0                       0                   0                   0                       0                    0            0           	for (size_t __i = 0; __i < _Nw; __i++)
    852,445,162 ( 0.04%) 1 ( 0.01%) 1 ( 0.01%)    425,222,884 ( 0.09%)          0                   0                       0                    0            0           	  if (_M_w[__i] != static_cast<_WordT>(0))
              .          .          .                       .                   .                   .                       .                    .            .           	    return true;
              .          .          .                       .                   .                   .                       .                    .            .           	return false;
              .          .          .                       .                   .                   .                       .                    .            .                 }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 size_t
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_count() const _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .                 {
        524,288 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           	size_t __result = 0;
    326,369,280 ( 0.01%) 0          0                       0                   0                   0                       0                    0            0           	for (size_t __i = 0; __i < _Nw; __i++)
    435,159,040 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)    108,789,760 ( 0.02%) 13,598,727 ( 0.13%) 13,598,721 ( 0.82%)    108,789,760 ( 0.02%)           0            0           	  __result += __builtin_popcountl(_M_w[__i]);
              .          .          .                       .                   .                   .                       .                    .            .           	return __result;
              .          .          .                       .                   .                   .                       .                    .            .                 }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 unsigned long
              .          .          .                       .                   .                   .                       .                    .            .                 _M_do_to_ulong() const;
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .           #if __cplusplus >= 201103L
              .          .          .                       .                   .                   .                       .                    .            .                 unsigned long long
-- line 224 ----------------------------------------
-- line 315 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .               }
              .          .          .                       .                   .                   .                       .                    .            .           #endif
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .             template<size_t _Nw>
              .          .          .                       .                   .                   .                       .                    .            .               size_t
              .          .          .                       .                   .                   .                       .                    .            .               _Base_bitset<_Nw>::
              .          .          .                       .                   .                   .                       .                    .            .               _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .               {
    593,854,476 ( 0.03%) 0          0                       0                   0                   0                       0                    0            0                 for (size_t __i = 0; __i < _Nw; __i++)
              .          .          .                       .                   .                   .                       .                    .            .           	{
    198,951,189 ( 0.01%) 0          0             198,951,189 ( 0.04%)          0                   0                       0                    0            0           	  _WordT __thisword = _M_w[__i];
    397,902,378 ( 0.02%) 0          0                       0                   0                   0                       0                    0            0           	  if (__thisword != static_cast<_WordT>(0))
        999,697 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
      2,999,091 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           		    + __builtin_ctzl(__thisword));
              .          .          .                       .                   .                   .                       .                    .            .           	}
              .          .          .                       .                   .                   .                       .                    .            .                 // not found, so return an indication of failure.
              .          .          .                       .                   .                   .                       .                    .            .                 return __not_found;
              .          .          .                       .                   .                   .                       .                    .            .               }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .             template<size_t _Nw>
              .          .          .                       .                   .                   .                       .                    .            .               size_t
              .          .          .                       .                   .                   .                       .                    .            .               _Base_bitset<_Nw>::
              .          .          .                       .                   .                   .                       .                    .            .               _M_do_find_next(size_t __prev, size_t __not_found) const _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .               {
              .          .          .                       .                   .                   .                       .                    .            .                 // make bound inclusive
      1,901,178 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0                 ++__prev;
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 // check out of bounds
              .          .          .                       .                   .                   .                       .                    .            .                 if (__prev >= _Nw * _GLIBCXX_BITSET_BITS_PER_WORD)
              .          .          .                       .                   .                   .                       .                    .            .           	return __not_found;
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 // search first word
              .          .          .                       .                   .                   .                       .                    .            .                 size_t __i = _S_whichword(__prev);
              .          .          .                       .                   .                   .                       .                    .            .                 _WordT __thisword = _M_w[__i];
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 // mask off bits below bound
      3,802,356 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)              0                   0                   0                       0                    0            0                 __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
              .          .          .                       .                   .                   .                       .                    .            .           
      3,802,356 ( 0.00%) 0          0               1,901,178 ( 0.00%)         55 ( 0.00%)          0                       0                    0            0                 if (__thisword != static_cast<_WordT>(0))
        600,808 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           	return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
      1,502,020 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           		+ __builtin_ctzl(__thisword));
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 // check subsequent words
      1,600,774 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0                 __i++;
    649,075,120 ( 0.03%) 0          0                       0                   0                   0                       0                    0            0                 for (; __i < _Nw; __i++)
              .          .          .                       .                   .                   .                       .                    .            .           	{
    215,892,133 ( 0.01%) 0          0             215,892,133 ( 0.05%)        175 ( 0.00%)          0                       0                    0            0           	  __thisword = _M_w[__i];
    431,784,266 ( 0.02%) 0          0                       0                   0                   0                       0                    0            0           	  if (__thisword != static_cast<_WordT>(0))
        601,077 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
      1,803,231 ( 0.00%) 0          0                       0                   0                   0                       0                    0            0           		    + __builtin_ctzl(__thisword));
              .          .          .                       .                   .                   .                       .                    .            .           	}
              .          .          .                       .                   .                   .                       .                    .            .                 // not found, so return an indication of failure.
              .          .          .                       .                   .                   .                       .                    .            .                 return __not_found;
              .          .          .                       .                   .                   .                       .                    .            .               } // end _M_do_find_next
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .             /**
              .          .          .                       .                   .                   .                       .                    .            .              *  Base class, specialization for a single word.
              .          .          .                       .                   .                   .                       .                    .            .              *
-- line 372 ----------------------------------------
-- line 649 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .             // Helper class to zero out the unused high-order bits in the highest word.
              .          .          .                       .                   .                   .                       .                    .            .             template<size_t _Extrabits>
              .          .          .                       .                   .                   .                       .                    .            .               struct _Sanitize
              .          .          .                       .                   .                   .                       .                    .            .               {
              .          .          .                       .                   .                   .                       .                    .            .                 typedef unsigned long _WordT;
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 static void
              .          .          .                       .                   .                   .                       .                    .            .                 _S_do_sanitize(_WordT& __val) _GLIBCXX_NOEXCEPT
      5,999,814 ( 0.00%) 0          0               5,999,808 ( 0.00%)          0                   0                       6 ( 0.00%)           0            0                 { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
              .          .          .                       .                   .                   .                       .                    .            .               };
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .             template<>
              .          .          .                       .                   .                   .                       .                    .            .               struct _Sanitize<0>
              .          .          .                       .                   .                   .                       .                    .            .               {
              .          .          .                       .                   .                   .                       .                    .            .                 typedef unsigned long _WordT;
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .                 static void
-- line 665 ----------------------------------------
-- line 822 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .           	~reference() _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .           	{ }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .           	// For b[i] = __x;
              .          .          .                       .                   .                   .                       .                    .            .           	reference&
              .          .          .                       .                   .                   .                       .                    .            .           	operator=(bool __x) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .           	{
 13,897,302,016 ( 0.60%) 0          0           6,948,651,008 ( 1.46%)          0                   0           6,948,651,008 ( 1.18%)           0            0           	  if (__x)
  9,434,167,076 ( 0.41%) 0          0           6,948,388,864 ( 1.46%)          0                   0           1,242,889,106 ( 0.21%)           0            0           	    *_M_wp |= _Base::_S_maskbit(_M_bpos);
              .          .          .                       .                   .                   .                       .                    .            .           	  else
 17,117,285,706 ( 0.73%) 0          0                       0                   0                   0           5,705,761,902 ( 0.97%)           0            0           	    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
              .          .          .                       .                   .                   .                       .                    .            .           	  return *this;
              .          .          .                       .                   .                   .                       .                    .            .           	}
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .           	// For b[i] = b[__j];
              .          .          .                       .                   .                   .                       .                    .            .           	reference&
              .          .          .                       .                   .                   .                       .                    .            .           	operator=(const reference& __j) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .           	{
              .          .          .                       .                   .                   .                       .                    .            .           	  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
-- line 841 ----------------------------------------
-- line 1438 ----------------------------------------
              .          .          .                       .                   .                   .                       .                    .            .                 __result &= __y;
              .          .          .                       .                   .                   .                       .                    .            .                 return __result;
              .          .          .                       .                   .                   .                       .                    .            .               }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .             template<size_t _Nb>
              .          .          .                       .                   .                   .                       .                    .            .               inline bitset<_Nb>
              .          .          .                       .                   .                   .                       .                    .            .               operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .               {
 63,147,979,200 ( 2.71%) 1 ( 0.01%) 1 ( 0.01%) 62,248,008,000 (13.06%) 48,433,350 ( 0.47%)          0          62,248,008,000 (10.61%)  50,294,532 ( 0.88%)   2 ( 0.00%)        bitset<_Nb> __result(__x);
              .          .          .                       .                   .                   .                       .                    .            .                 __result |= __y;
              .          .          .                       .                   .                   .                       .                    .            .                 return __result;
              .          .          .                       .                   .                   .                       .                    .            .               }
              .          .          .                       .                   .                   .                       .                    .            .           
              .          .          .                       .                   .                   .                       .                    .            .             template <size_t _Nb>
              .          .          .                       .                   .                   .                       .                    .            .               inline bitset<_Nb>
              .          .          .                       .                   .                   .                       .                    .            .               operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
              .          .          .                       .                   .                   .                       .                    .            .               {
-- line 1454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/ranges_base.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr         D1mr       DLmr       Dw                 D1mw       DLmw       

-- line 724 ----------------------------------------
            .          .          .          .          .          .                  .          .          .                 constexpr iter_difference_t<_It>
            .          .          .          .          .          .                  .          .          .                 operator()(_It& __it, iter_difference_t<_It> __n, _Sent __bound) const
            .          .          .          .          .          .                  .          .          .                 {
            .          .          .          .          .          .                  .          .          .           	if constexpr (sized_sentinel_for<_Sent, _It>)
            .          .          .          .          .          .                  .          .          .           	  {
            .          .          .          .          .          .                  .          .          .           	    const auto __diff = __bound - __it;
            .          .          .          .          .          .                  .          .          .           
            .          .          .          .          .          .                  .          .          .           	    // n and bound must not lead in opposite directions:
       26,507 ( 0.00%) 0          0          0          0          0                  0          0          0           	    __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));
1,892,946,845 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%) 0          0          0                  0          0          0           	    const auto __absdiff = __diff < 0 ? -__diff : __diff;
1,408,783,028 ( 0.06%) 3 ( 0.04%) 3 ( 0.04%) 0          0          0          1,000,000 ( 0.00%) 0          0           	    const auto __absn = __n < 0 ? -__n : __n;;
  928,433,662 ( 0.04%) 0          0          0          0          0                  0          0          0           	    if (__absn >= __absdiff)
            .          .          .          .          .          .                  .          .          .           	      {
            .          .          .          .          .          .                  .          .          .           		(*this)(__it, __bound);
            .          .          .          .          .          .                  .          .          .           		return __n - __diff;
            .          .          .          .          .          .                  .          .          .           	      }
            .          .          .          .          .          .                  .          .          .           	    else
            .          .          .          .          .          .                  .          .          .           	      {
            .          .          .          .          .          .                  .          .          .           		(*this)(__it, __n);
            .          .          .          .          .          .                  .          .          .           		return 0;
-- line 743 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/alphabet/quality/phred_base.hpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr         D1mr       DLmr       Dw         D1mw       DLmw       

-- line 126 ----------------------------------------
            .          .          .          .          .          .          .          .          .                   return assign_rank(phred_to_rank[static_cast<rank_type>(p)]);
            .          .          .          .          .          .          .          .          .               }
            .          .          .          .          .          .          .          .          .               //!\}
            .          .          .          .          .          .          .          .          .           
            .          .          .          .          .          .          .          .          .           private:
            .          .          .          .          .          .          .          .          .               //!\copydoc seqan3::dna4::char_to_rank
            .          .          .          .          .          .          .          .          .               static constexpr rank_type char_to_rank(char_type const chr)
            .          .          .          .          .          .          .          .          .               {
  600,000,524 ( 0.03%) 0          0          0          0          0          0          0          0                   int64_t difference = static_cast<int64_t>(chr) - static_cast<int64_t>(derived_type::offset_char);
2,400,002,096 ( 0.10%) 2 ( 0.02%) 2 ( 0.03%) 0          0          0          0          0          0                   return std::clamp<int64_t>(difference, 0, alphabet_size - 1);
            .          .          .          .          .          .          .          .          .               }
            .          .          .          .          .          .          .          .          .           
            .          .          .          .          .          .          .          .          .               //!\copydoc seqan3::dna4::rank_to_char
            .          .          .          .          .          .          .          .          .               static constexpr char_type rank_to_char(rank_type const rank)
            .          .          .          .          .          .          .          .          .               {
  600,000,524 ( 0.03%) 0          0          0          0          0          0          0          0                   return rank + derived_type::offset_char;
            .          .          .          .          .          .          .          .          .               }
            .          .          .          .          .          .          .          .          .           
            .          .          .          .          .          .          .          .          .               // clang-format off
            .          .          .          .          .          .          .          .          .               //!\brief Phred to rank conversion table.
            .          .          .          .          .          .          .          .          .               static constexpr std::array<rank_type, 256> phred_to_rank
            .          .          .          .          .          .          .          .          .               {
            .          .          .          .          .          .          .          .          .                   []() constexpr {
            .          .          .          .          .          .          .          .          .                       std::array<rank_type, 256> ret{};
-- line 149 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable.h
--------------------------------------------------------------------------------
Ir                      I1mr       ILmr       Dr                     D1mr                   DLmr       Dw                     D1mw               DLmw       

-- line 414 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .                 _M_update_bbegin(__node_ptr __n)
             .          .          .                      .                      .          .                      .                  .          .                 {
             .          .          .                      .                      .          .                      .                  .          .           	_M_before_begin._M_nxt = __n;
             .          .          .                      .                      .          .                      .                  .          .           	_M_update_bbegin();
             .          .          .                      .                      .          .                      .                  .          .                 }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 bool
             .          .          .                      .                      .          .                      .                  .          .                 _M_uses_single_bucket(__buckets_ptr __bkts) const
             2 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 { return __builtin_expect(__bkts == &_M_single_bucket, false); }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 bool
             .          .          .                      .                      .          .                      .                  .          .                 _M_uses_single_bucket() const
             .          .          .                      .                      .          .                      .                  .          .                 { return _M_uses_single_bucket(_M_buckets); }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 __hashtable_alloc&
             .          .          .                      .                      .          .                      .                  .          .                 _M_base_alloc() { return *this; }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 __buckets_ptr
             .          .          .                      .                      .          .                      .                  .          .                 _M_allocate_buckets(size_type __bkt_count)
             .          .          .                      .                      .          .                      .                  .          .                 {
            50 ( 0.00%) 0          0                      0                      0          0                      0                  0          0           	if (__builtin_expect(__bkt_count == 1, false))
             .          .          .                      .                      .          .                      .                  .          .           	  {
             .          .          .                      .                      .          .                      .                  .          .           	    _M_single_bucket = nullptr;
            38 ( 0.00%) 0          0                      0                      0          0                     13 ( 0.00%)         0          0           	    return &_M_single_bucket;
             .          .          .                      .                      .          .                      .                  .          .           	  }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           	return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
             .          .          .                      .                      .          .                      .                  .          .                 }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 void
             .          .          .                      .                      .          .                      .                  .          .                 _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
             .          .          .                      .                      .          .                      .                  .          .                 {
            56 ( 0.00%) 0          0                     14 ( 0.00%)             8 ( 0.00%) 0                      0                  0          0           	if (_M_uses_single_bucket(__bkts))
             .          .          .                      .                      .          .                      .                  .          .           	  return;
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           	__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
             .          .          .                      .                      .          .                      .                  .          .                 }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 void
             .          .          .                      .                      .          .                      .                  .          .                 _M_deallocate_buckets()
            56 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)            56 ( 0.00%)            14 ( 0.00%) 0                      0                  0          0                 { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
             .          .          .                      .                      .          .                      .                  .          .                 // their before begin node.
             .          .          .                      .                      .          .                      .                  .          .                 __node_ptr
             .          .          .                      .                      .          .                      .                  .          .                 _M_bucket_begin(size_type __bkt) const;
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 __node_ptr
             .          .          .                      .                      .          .                      .                  .          .                 _M_begin() const
     2,546,625 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)     2,546,625 ( 0.00%)        56,303 ( 0.00%) 2 ( 0.00%)             0                  0          0                 { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 // Assign *this using another _Hashtable instance. Whether elements
             .          .          .                      .                      .          .                      .                  .          .                 // are copied or moved depends on the _Ht reference.
             .          .          .                      .                      .          .                      .                  .          .                 template<typename _Ht>
             .          .          .                      .                      .          .                      .                  .          .           	void
             .          .          .                      .                      .          .                      .                  .          .           	_M_assign_elements(_Ht&&);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 template<typename _Ht, typename _NodeGenerator>
-- line 471 ----------------------------------------
-- line 520 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .                 template<typename _InputIterator>
             .          .          .                      .                      .          .                      .                  .          .           	_Hashtable(_InputIterator __first, _InputIterator __last,
             .          .          .                      .                      .          .                      .                  .          .           		   size_type __bkt_count_hint,
             .          .          .                      .                      .          .                      .                  .          .           		   const _Hash&, const _Equal&, const allocator_type&,
             .          .          .                      .                      .          .                      .                  .          .           		   false_type __uks);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .               public:
             .          .          .                      .                      .          .                      .                  .          .                 // Constructor, destructor, assignment, swap
            16 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                      0          0                     13 ( 0.00%)         1 ( 0.00%) 1 ( 0.00%)        _Hashtable() = default;
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 _Hashtable(const _Hashtable&);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 _Hashtable(const _Hashtable&, const allocator_type&);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 explicit
             .          .          .                      .                      .          .                      .                  .          .                 _Hashtable(size_type __bkt_count_hint,
             .          .          .                      .                      .          .                      .                  .          .           		 const _Hash& __hf = _Hash(),
-- line 536 ----------------------------------------
-- line 787 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .               private:
             .          .          .                      .                      .          .                      .                  .          .                 // Bucket index computation helpers.
             .          .          .                      .                      .          .                      .                  .          .                 size_type
             .          .          .                      .                      .          .                      .                  .          .                 _M_bucket_index(const __node_value_type& __n) const noexcept
             .          .          .                      .                      .          .                      .                  .          .                 { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 size_type
             .          .          .                      .                      .          .                      .                  .          .                 _M_bucket_index(__hash_code __c) const
 1,912,947,726 ( 0.08%) 0          0          1,912,947,726 ( 0.40%)     1,310,701 ( 0.01%) 0                      0                  0          0                 { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 // Find and insert helper functions and types
             .          .          .                      .                      .          .                      .                  .          .                 // Find the node before the one matching the criteria.
             .          .          .                      .                      .          .                      .                  .          .                 __node_base_ptr
             .          .          .                      .                      .          .                      .                  .          .                 _M_find_before_node(size_type, const key_type&, __hash_code) const;
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 template<typename _Kt>
             .          .          .                      .                      .          .                      .                  .          .           	__node_base_ptr
-- line 803 ----------------------------------------
-- line 1748 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 auto __beg = __ite++;
             .          .          .                      .                      .          .                      .                  .          .                 if (__unique_keys::value)
             .          .          .                      .                      .          .                      .                  .          .           	return { __beg, __ite };
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 // All equivalent values are next to each other, if we find a
             .          .          .                      .                      .          .                      .                  .          .                 // non-equivalent value after an equivalent one it means that we won't
             .          .          .                      .                      .          .                      .                  .          .                 // find any new equivalent value.
   119,422,638 ( 0.01%) 0          0                      0                      0          0                    520 ( 0.00%)       273 ( 0.00%) 0                 while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
             .          .          .                      .                      .          .                      .                  .          .           	++__ite;
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 return { __beg, __ite };
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           #if __cplusplus > 201703L
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
-- line 1764 ----------------------------------------
-- line 1825 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               auto
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_find_before_node(size_type __bkt, const key_type& __k,
             .          .          .                      .                      .          .                      .                  .          .           			__hash_code __code) const
             .          .          .                      .                      .          .                      .                  .          .               -> __node_base_ptr
             .          .          .                      .                      .          .                      .                  .          .               {
 5,628,729,539 ( 0.24%) 1 ( 0.01%) 1 ( 0.01%) 3,681,272,434 ( 0.77%) 1,690,985,455 (16.42%) 0                      0                  0          0                 __node_base_ptr __prev_p = _M_buckets[__bkt];
 3,800,694,032 ( 0.16%) 0          0                      0                      0          0                      0                  0          0                 if (!__prev_p)
             .          .          .                      .                      .          .                      .                  .          .           	return nullptr;
             .          .          .                      .                      .          .                      .                  .          .           
   720,375,363 ( 0.03%) 0          0            720,375,363 ( 0.15%)   615,859,568 ( 5.98%) 1 ( 0.00%)             0                  0          0                 for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
             .          .          .                      .                      .          .                      .                  .          .           	   __p = __p->_M_next())
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  if (this->_M_equals(__k, __code, *__p))
             .          .          .                      .                      .          .                      .                  .          .           	    return __prev_p;
             .          .          .                      .                      .          .                      .                  .          .           
 3,127,987,832 ( 0.13%) 0          0            591,828,349 ( 0.12%)             0          0                      0                  0          0           	  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
             .          .          .                      .                      .          .                      .                  .          .           	    break;
             .          .          .                      .                      .          .                      .                  .          .           	  __prev_p = __p;
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 return nullptr;
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
-- line 1851 ----------------------------------------
-- line 1882 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
             .          .          .                      .                      .          .                      .                  .          .               {
   336,429,166 ( 0.01%) 0          0            134,571,662 ( 0.03%)             4 ( 0.00%) 0                      0                  0          0                 if (_M_buckets[__bkt])
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  // Bucket is not empty, we just need to insert the new node
             .          .          .                      .                      .          .                      .                  .          .           	  // after the bucket before begin.
   834,029,138 ( 0.04%) 0          0            417,014,569 ( 0.09%)           607 ( 0.00%) 0            417,014,569 ( 0.07%)       527 ( 0.00%) 0           	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
 1,249,891,651 ( 0.05%) 0          0            417,014,569 ( 0.09%)           535 ( 0.00%) 0            417,014,569 ( 0.07%)       533 ( 0.00%) 0           	  _M_buckets[__bkt]->_M_nxt = __node;
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .                 else
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  // The bucket is empty, the new node is inserted at the
             .          .          .                      .                      .          .                      .                  .          .           	  // beginning of the singly-linked list and the bucket will
             .          .          .                      .                      .          .                      .                  .          .           	  // contain _M_before_begin pointer.
 3,472,776,427 ( 0.15%) 2 ( 0.02%) 2 ( 0.03%) 2,293,139,693 ( 0.48%)             0          0          1,179,636,734 ( 0.20%)         8 ( 0.00%) 0           	  __node->_M_nxt = _M_before_begin._M_nxt;
 1,179,636,734 ( 0.05%) 0          0                      0                      0          0          1,179,636,734 ( 0.20%)         0          0           	  _M_before_begin._M_nxt = __node;
             .          .          .                      .                      .          .                      .                  .          .           
 2,359,273,468 ( 0.10%) 0          0                      0                      0          0                      0                  0          0           	  if (__node->_M_nxt)
             .          .          .                      .                      .          .                      .                  .          .           	    // We must update former begin bucket that is pointing to
             .          .          .                      .                      .          .                      .                  .          .           	    // _M_before_begin.
 2,291,826,660 ( 0.10%) 0          0          1,113,476,452 ( 0.23%)             0          0          1,178,350,208 ( 0.20%)   139,439 ( 0.00%) 0           	    _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;
             .          .          .                      .                      .          .                      .                  .          .           
 3,538,910,202 ( 0.15%) 0          0                      0                      0          0          1,179,636,734 ( 0.20%)         0          0           	  _M_buckets[__bkt] = &_M_before_begin;
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
-- line 1918 ----------------------------------------
-- line 2006 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               auto
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
             .          .          .                      .                      .          .                      .                  .          .           			  __node_ptr __node, size_type __n_elt)
             .          .          .                      .                      .          .                      .                  .          .               -> iterator
             .          .          .                      .                      .          .                      .                  .          .               {
   134,571,662 ( 0.01%) 0          0             67,285,831 ( 0.01%)             0          0             67,285,831 ( 0.01%)    51,672 ( 0.00%) 0                 const __rehash_state& __saved_state = _M_rehash_policy._M_state();
             .          .          .                      .                      .          .                      .                  .          .                 std::pair<bool, std::size_t> __do_rehash
   406,235,128 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)   201,857,493 ( 0.04%)         9,492 ( 0.00%) 0             68,545,902 ( 0.01%)         0          0           	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
             .          .          .                      .                      .          .                      .                  .          .           					  __n_elt);
             .          .          .                      .                      .          .                      .                  .          .           
   134,571,662 ( 0.01%) 0          0                      0                      0          0                      0                  0          0                 if (__do_rehash.first)
             .          .          .                      .                      .          .                      .                  .          .           	{
            33 ( 0.00%) 0          0                     11 ( 0.00%)             0          0                     11 ( 0.00%)         0          0           	  _M_rehash(__do_rehash.second, __saved_state);
             .          .          .                      .                      .          .                      .                  .          .           	  __bkt = _M_bucket_index(__code);
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 this->_M_store_code(*__node, __code);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 // Always insert at the beginning of the bucket.
             .          .          .                      .                      .          .                      .                  .          .                 _M_insert_bucket_begin(__bkt, __node);
   134,571,662 ( 0.01%) 0          0             67,285,831 ( 0.01%)             0          0                      0                  0          0                 ++_M_element_count;
             .          .          .                      .                      .          .                      .                  .          .                 return iterator(__node);
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               auto
-- line 2037 ----------------------------------------
-- line 2038 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_insert_multi_node(__node_ptr __hint,
             .          .          .                      .                      .          .                      .                  .          .           			 __hash_code __code, __node_ptr __node)
             .          .          .                      .                      .          .                      .                  .          .               -> iterator
             .          .          .                      .                      .          .                      .                  .          .               {
             .          .          .                      .                      .          .                      .                  .          .                 const __rehash_state& __saved_state = _M_rehash_policy._M_state();
             .          .          .                      .                      .          .                      .                  .          .                 std::pair<bool, std::size_t> __do_rehash
10,251,683,454 ( 0.44%) 1 ( 0.01%) 1 ( 0.01%) 3,417,227,818 ( 0.72%)        27,067 ( 0.00%) 0          3,417,227,818 ( 0.58%)         0          0           	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);
             .          .          .                      .                      .          .                      .                  .          .           
 3,417,227,818 ( 0.15%) 0          0                      0                      0          0                      0                  0          0                 if (__do_rehash.first)
             .          .          .                      .                      .          .                      .                  .          .           	_M_rehash(__do_rehash.second, __saved_state);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 this->_M_store_code(*__node, __code);
             .          .          .                      .                      .          .                      .                  .          .                 const key_type& __k = _ExtractKey{}(__node->_M_v());
             .          .          .                      .                      .          .                      .                  .          .                 size_type __bkt = _M_bucket_index(__code);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 // Find the node before an equivalent one or use hint if it exists and
             .          .          .                      .                      .          .                      .                  .          .                 // if it is equivalent.
-- line 2056 ----------------------------------------
-- line 2058 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           	= __builtin_expect(__hint != nullptr, false)
             .          .          .                      .                      .          .                      .                  .          .           	  && this->_M_equals(__k, __code, *__hint)
             .          .          .                      .                      .          .                      .                  .          .           	    ? __hint
             .          .          .                      .                      .          .                      .                  .          .           	    : _M_find_before_node(__bkt, __k, __code);
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 if (__prev)
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  // Insert after the node before the equivalent one.
   358,496,874 ( 0.02%) 0          0            179,248,437 ( 0.04%)             3 ( 0.00%) 0            179,248,437 ( 0.03%)         3 ( 0.00%) 0           	  __node->_M_nxt = __prev->_M_nxt;
   179,248,437 ( 0.01%) 0          0                      0                      0          0            179,248,437 ( 0.03%)         0          0           	  __prev->_M_nxt = __node;
             .          .          .                      .                      .          .                      .                  .          .           	  if (__builtin_expect(__prev == __hint, false))
             .          .          .                      .                      .          .                      .                  .          .           	    // hint might be the last bucket node, in this case we need to
             .          .          .                      .                      .          .                      .                  .          .           	    // update next bucket.
             .          .          .                      .                      .          .                      .                  .          .           	    if (__node->_M_nxt
             .          .          .                      .                      .          .                      .                  .          .           		&& !this->_M_equals(__k, __code, *__node->_M_next()))
             .          .          .                      .                      .          .                      .                  .          .           	      {
             .          .          .                      .                      .          .                      .                  .          .           		size_type __next_bkt = _M_bucket_index(*__node->_M_next());
             .          .          .                      .                      .          .                      .                  .          .           		if (__next_bkt != __bkt)
-- line 2075 ----------------------------------------
-- line 2076 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           		  _M_buckets[__next_bkt] = __node;
             .          .          .                      .                      .          .                      .                  .          .           	      }
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .                 else
             .          .          .                      .                      .          .                      .                  .          .           	// The inserted node has no equivalent in the hashtable. We must
             .          .          .                      .                      .          .                      .                  .          .           	// insert the new node at the beginning of the bucket to preserve
             .          .          .                      .                      .          .                      .                  .          .           	// equivalent elements' relative positions.
             .          .          .                      .                      .          .                      .                  .          .           	_M_insert_bucket_begin(__bkt, __node);
 1,708,613,909 ( 0.07%) 1 ( 0.01%) 1 ( 0.01%) 1,708,613,909 ( 0.36%)           586 ( 0.00%) 0                      0                  0          0                 ++_M_element_count;
             .          .          .                      .                      .          .                      .                  .          .                 return iterator(__node);
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             // Insert v if no element with its key is already present.
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
-- line 2092 ----------------------------------------
-- line 2313 ----------------------------------------
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               clear() noexcept
             .          .          .                      .                      .          .                      .                  .          .               {
             .          .          .                      .                      .          .                      .                  .          .                 this->_M_deallocate_nodes(_M_begin());
     7,719,483 ( 0.00%) 3 ( 0.04%) 3 ( 0.04%)     3,859,740 ( 0.00%)        30,654 ( 0.00%) 0              1,286,581 ( 0.00%)         0          0                 __builtin_memset(_M_buckets, 0,
             .          .          .                      .                      .          .                      .                  .          .           		       _M_bucket_count * sizeof(__node_base_ptr));
     1,286,581 ( 0.00%) 0          0                      0                      0          0              1,286,581 ( 0.00%) 1,286,427 ( 0.02%) 0                 _M_element_count = 0;
     1,286,581 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)             0                      0          0              1,286,581 ( 0.00%)         0          0                 _M_before_begin._M_nxt = nullptr;
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               rehash(size_type __bkt_count)
             .          .          .                      .                      .          .                      .                  .          .               {
             1 ( 0.00%) 0          0                      0                      0          0                      1 ( 0.00%)         0          0                 const __rehash_state& __saved_state = _M_rehash_policy._M_state();
             .          .          .                      .                      .          .                      .                  .          .                 __bkt_count
             .          .          .                      .                      .          .                      .                  .          .           	= std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
             .          .          .                      .                      .          .                      .                  .          .           		   __bkt_count);
             6 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                      0          0                      1 ( 0.00%)         0          0                 __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);
             .          .          .                      .                      .          .                      .                  .          .           
             2 ( 0.00%) 0          0                      1 ( 0.00%)             0          0                      0                  0          0                 if (__bkt_count != _M_bucket_count)
             3 ( 0.00%) 0          0                      1 ( 0.00%)             0          0                      1 ( 0.00%)         0          0           	_M_rehash(__bkt_count, __saved_state);
             .          .          .                      .                      .          .                      .                  .          .                 else
             .          .          .                      .                      .          .                      .                  .          .           	// No rehash, restore previous state to keep it consistent with
             .          .          .                      .                      .          .                      .                  .          .           	// container state.
             .          .          .                      .                      .          .                      .                  .          .           	_M_rehash_policy._M_reset(__saved_state);
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
            96 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)             0                      0          0                     48 ( 0.00%)         0          0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_rehash(size_type __bkt_count, const __rehash_state& __state)
             .          .          .                      .                      .          .                      .                  .          .               {
             .          .          .                      .                      .          .                      .                  .          .                 __try
             .          .          .                      .                      .          .                      .                  .          .           	{
            65 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                      0          0                     13 ( 0.00%)         0          0           	  _M_rehash_aux(__bkt_count, __unique_keys{});
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .                 __catch(...)
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  // A failure here means that buckets allocation failed.  We only
             .          .          .                      .                      .          .                      .                  .          .           	  // have to restore hash policy previous state.
             .          .          .                      .                      .          .                      .                  .          .           	  _M_rehash_policy._M_reset(__state);
             .          .          .                      .                      .          .                      .                  .          .           	  __throw_exception_again;
             .          .          .                      .                      .          .                      .                  .          .           	}
            72 ( 0.00%) 0          0                     60 ( 0.00%)             7 ( 0.00%) 0                      0                  0          0               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             // Rehash when there is no equivalent elements.
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
             .          .          .                      .                      .          .                      .                  .          .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_rehash_aux(size_type __bkt_count, true_type /* __uks */)
             .          .          .                      .                      .          .                      .                  .          .               {
             .          .          .                      .                      .          .                      .                  .          .                 __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
             .          .          .                      .                      .          .                      .                  .          .                 __node_ptr __p = _M_begin();
            12 ( 0.00%) 0          0                      0                      0          0                     12 ( 0.00%)         0          0                 _M_before_begin._M_nxt = nullptr;
            12 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 std::size_t __bbegin_bkt = 0;
        59,593 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 while (__p)
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  __node_ptr __next = __p->_M_next();
             .          .          .                      .                      .          .                      .                  .          .           	  std::size_t __bkt
             .          .          .                      .                      .          .                      .                  .          .           	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
       119,116 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        29,779 ( 0.00%)        10,894 ( 0.00%) 0                      0                  0          0           	  if (!__new_buckets[__bkt])
             .          .          .                      .                      .          .                      .                  .          .           	    {
        56,934 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)        28,467 ( 0.00%)             0          0                 28,467 ( 0.00%)         0          0           	      __p->_M_nxt = _M_before_begin._M_nxt;
        28,467 ( 0.00%) 0          0                      0                      0          0                 28,467 ( 0.00%)         0          0           	      _M_before_begin._M_nxt = __p;
        28,479 ( 0.00%) 0          0                      0                      0          0                 28,467 ( 0.00%)         0          0           	      __new_buckets[__bkt] = &_M_before_begin;
        56,934 ( 0.00%) 0          0                 28,467 ( 0.00%)             0          0                      0                  0          0           	      if (__p->_M_nxt)
        28,456 ( 0.00%) 0          0                      0                      0          0                 28,456 ( 0.00%)         0          0           		__new_buckets[__bbegin_bkt] = __p;
        56,923 ( 0.00%) 0          0                      0                      0          0                      0                  0          0           	      __bbegin_bkt = __bkt;
             .          .          .                      .                      .          .                      .                  .          .           	    }
             .          .          .                      .                      .          .                      .                  .          .           	  else
             .          .          .                      .                      .          .                      .                  .          .           	    {
         2,624 ( 0.00%) 0          0                  1,312 ( 0.00%)           563 ( 0.00%) 0                  1,312 ( 0.00%)         0          0           	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
         2,624 ( 0.00%) 0          0                  1,312 ( 0.00%)             0          0                  1,312 ( 0.00%)         0          0           	      __new_buckets[__bkt]->_M_nxt = __p;
             .          .          .                      .                      .          .                      .                  .          .           	    }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           	  __p = __next;
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 _M_deallocate_buckets();
            12 ( 0.00%) 0          0                      0                      0          0                     12 ( 0.00%)         0          0                 _M_bucket_count = __bkt_count;
            12 ( 0.00%) 0          0                      0                      0          0                     12 ( 0.00%)         0          0                 _M_buckets = __new_buckets;
             .          .          .                      .                      .          .                      .                  .          .               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .             // Rehash when there can be equivalent elements, preserve their relative
             .          .          .                      .                      .          .                      .                  .          .             // order.
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Key, typename _Value, typename _Alloc,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _ExtractKey, typename _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _Hash, typename _RangeHash, typename _Unused,
             .          .          .                      .                      .          .                      .                  .          .           	   typename _RehashPolicy, typename _Traits>
             .          .          .                      .                      .          .                      .                  .          .               void
           117 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                      0          0                     78 ( 0.00%)         0          0               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
             .          .          .                      .                      .          .                      .                  .          .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
             .          .          .                      .                      .          .                      .                  .          .               _M_rehash_aux(size_type __bkt_count, false_type /* __uks */)
             .          .          .                      .                      .          .                      .                  .          .               {
             .          .          .                      .                      .          .                      .                  .          .                 __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
             .          .          .                      .                      .          .                      .                  .          .                 __node_ptr __p = _M_begin();
            13 ( 0.00%) 0          0                      0                      0          0                     13 ( 0.00%)         0          0                 _M_before_begin._M_nxt = nullptr;
            12 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 std::size_t __bbegin_bkt = 0;
            12 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 std::size_t __prev_bkt = 0;
            12 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 __node_ptr __prev_p = nullptr;
            12 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 bool __check_bucket = false;
             .          .          .                      .                      .          .                      .                  .          .           
       330,606 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 while (__p)
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  __node_ptr __next = __p->_M_next();
             .          .          .                      .                      .          .                      .                  .          .           	  std::size_t __bkt
             .          .          .                      .                      .          .                      .                  .          .           	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
             .          .          .                      .                      .          .                      .                  .          .           
       495,888 ( 0.00%) 0          0                      0                      0          0                      0                  0          0           	  if (__prev_p && __prev_bkt == __bkt)
             .          .          .                      .                      .          .                      .                  .          .           	    {
             .          .          .                      .                      .          .                      .                  .          .           	      // Previous insert was already in this bucket, we insert after
             .          .          .                      .                      .          .                      .                  .          .           	      // the previously inserted one to preserve equivalent elements
             .          .          .                      .                      .          .                      .                  .          .           	      // relative order.
        20,576 ( 0.00%) 0          0                 10,288 ( 0.00%)             0          0                 10,288 ( 0.00%)         0          0           	      __p->_M_nxt = __prev_p->_M_nxt;
        10,288 ( 0.00%) 0          0                      0                      0          0                 10,288 ( 0.00%)         0          0           	      __prev_p->_M_nxt = __p;
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           	      // Inserting after a node in a bucket require to check that we
             .          .          .                      .                      .          .                      .                  .          .           	      // haven't change the bucket last node, in this case next
             .          .          .                      .                      .          .                      .                  .          .           	      // bucket containing its before begin node must be updated. We
             .          .          .                      .                      .          .                      .                  .          .           	      // schedule a check as soon as we move out of the sequence of
             .          .          .                      .                      .          .                      .                  .          .           	      // equivalent nodes to limit the number of checks.
        10,288 ( 0.00%) 0          0                      0                      0          0                      0                  0          0           	      __check_bucket = true;
             .          .          .                      .                      .          .                      .                  .          .           	    }
             .          .          .                      .                      .          .                      .                  .          .           	  else
             .          .          .                      .                      .          .                      .                  .          .           	    {
       144,720 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                      0          0                      0                  0          0           	      if (__check_bucket)
             .          .          .                      .                      .          .                      .                  .          .           		{
             .          .          .                      .                      .          .                      .                  .          .           		  // Check if we shall update the next bucket because of
             .          .          .                      .                      .          .                      .                  .          .           		  // insertions into __prev_bkt bucket.
        14,982 ( 0.00%) 0          0                  4,994 ( 0.00%)             0          0                      0                  0          0           		  if (__prev_p->_M_nxt)
             .          .          .                      .                      .          .                      .                  .          .           		    {
             .          .          .                      .                      .          .                      .                  .          .           		      std::size_t __next_bkt
             .          .          .                      .                      .          .                      .                  .          .           			= __hash_code_base::_M_bucket_index(
             .          .          .                      .                      .          .                      .                  .          .           			  *__prev_p->_M_next(), __bkt_count);
         9,988 ( 0.00%) 0          0                      0                      0          0                      0                  0          0           		      if (__next_bkt != __prev_bkt)
         4,002 ( 0.00%) 0          0                      0                      0          0                  4,002 ( 0.00%)         0          0           			__new_buckets[__next_bkt] = __prev_p;
             .          .          .                      .                      .          .                      .                  .          .           		    }
             .          .          .                      .                      .          .                      .                  .          .           		  __check_bucket = false;
             .          .          .                      .                      .          .                      .                  .          .           		}
             .          .          .                      .                      .          .                      .                  .          .           
       289,440 ( 0.00%) 0          0                 72,360 ( 0.00%)        66,781 ( 0.00%) 0                      0                  0          0           	      if (!__new_buckets[__bkt])
             .          .          .                      .                      .          .                      .                  .          .           		{
       117,826 ( 0.00%) 0          0                 58,913 ( 0.00%)             0          0                 58,913 ( 0.00%)         0          0           		  __p->_M_nxt = _M_before_begin._M_nxt;
        58,913 ( 0.00%) 0          0                      0                      0          0                 58,913 ( 0.00%)         0          0           		  _M_before_begin._M_nxt = __p;
        58,937 ( 0.00%) 0          0                      0                      0          0                 58,913 ( 0.00%)         0          0           		  __new_buckets[__bkt] = &_M_before_begin;
       117,826 ( 0.00%) 0          0                 58,913 ( 0.00%)             0          0                      0                  0          0           		  if (__p->_M_nxt)
       117,802 ( 0.00%) 0          0                      0                      0          0                 58,901 ( 0.00%)         0          0           		    __new_buckets[__bbegin_bkt] = __p;
             .          .          .                      .                      .          .                      .                  .          .           		  __bbegin_bkt = __bkt;
             .          .          .                      .                      .          .                      .                  .          .           		}
             .          .          .                      .                      .          .                      .                  .          .           	      else
             .          .          .                      .                      .          .                      .                  .          .           		{
        26,894 ( 0.00%) 0          0                 13,447 ( 0.00%)        12,602 ( 0.00%) 0                 13,447 ( 0.00%)         0          0           		  __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
        40,341 ( 0.00%) 0          0                 13,447 ( 0.00%)             0          0                 13,447 ( 0.00%)         0          0           		  __new_buckets[__bkt]->_M_nxt = __p;
             .          .          .                      .                      .          .                      .                  .          .           		}
             .          .          .                      .                      .          .                      .                  .          .           	    }
             .          .          .                      .                      .          .                      .                  .          .           	  __prev_p = __p;
             .          .          .                      .                      .          .                      .                  .          .           	  __prev_bkt = __bkt;
             .          .          .                      .                      .          .                      .                  .          .           	  __p = __next;
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .           
            24 ( 0.00%) 0          0                      0                      0          0                      0                  0          0                 if (__check_bucket && __prev_p->_M_nxt)
             .          .          .                      .                      .          .                      .                  .          .           	{
             .          .          .                      .                      .          .                      .                  .          .           	  std::size_t __next_bkt
             .          .          .                      .                      .          .                      .                  .          .           	    = __hash_code_base::_M_bucket_index(*__prev_p->_M_next(),
             .          .          .                      .                      .          .                      .                  .          .           						__bkt_count);
             .          .          .                      .                      .          .                      .                  .          .           	  if (__next_bkt != __prev_bkt)
             .          .          .                      .                      .          .                      .                  .          .           	    __new_buckets[__next_bkt] = __prev_p;
             .          .          .                      .                      .          .                      .                  .          .           	}
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .                 _M_deallocate_buckets();
            13 ( 0.00%) 0          0                      0                      0          0                     13 ( 0.00%)         0          0                 _M_bucket_count = __bkt_count;
            13 ( 0.00%) 0          0                      0                      0          0                     13 ( 0.00%)         0          0                 _M_buckets = __new_buckets;
           104 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)            91 ( 0.00%)             7 ( 0.00%) 0                      0                  0          0               }
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           #if __cplusplus > 201402L
             .          .          .                      .                      .          .                      .                  .          .             template<typename, typename, typename> class _Hash_merge_helper { };
             .          .          .                      .                      .          .                      .                  .          .           #endif // C++17
             .          .          .                      .                      .          .                      .                  .          .           
             .          .          .                      .                      .          .                      .                  .          .           #if __cpp_deduction_guides >= 201606
             .          .          .                      .                      .          .                      .                  .          .             // Used to constrain deduction guides
             .          .          .                      .                      .          .                      .                  .          .             template<typename _Hash>
-- line 2511 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/vector.tcc
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                     D1mr               DLmr               Dw                     D1mw                DLmw                

-- line 63 ----------------------------------------
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               void
            .           .           .                      .                  .                  .                      .                   .                   .               vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .               reserve(size_type __n)
            .           .           .                      .                  .                  .                      .                   .                   .               {
            .           .           .                      .                  .                  .                      .                   .                   .                 if (__n > this->max_size())
            .           .           .                      .                  .                  .                      .                   .                   .           	__throw_length_error(__N("vector::reserve"));
            2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                  0                  0                      0                   0                   0                 if (this->capacity() < __n)
            .           .           .                      .                  .                  .                      .                   .                   .           	{
            .           .           .                      .                  .                  .                      .                   .                   .           	  const size_type __old_size = size();
            .           .           .                      .                  .                  .                      .                   .                   .           	  pointer __tmp;
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .           	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
            .           .           .                      .                  .                  .                      .                   .                   .           	    {
            .           .           .                      .                  .                  .                      .                   .                   .           	      __tmp = this->_M_allocate(__n);
            1 ( 0.00%)  0           0                      1 ( 0.00%)         0                  0                      0                   0                   0           	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
            .           .           .                      .                  .                  .                      .                   .                   .           			  __tmp, _M_get_Tp_allocator());
            .           .           .                      .                  .                  .                      .                   .                   .           	    }
            .           .           .                      .                  .                  .                      .                   .                   .           	  else
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .           	    {
            .           .           .                      .                  .                  .                      .                   .                   .           	      __tmp = _M_allocate_and_copy(__n,
            .           .           .                      .                  .                  .                      .                   .                   .           		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
            .           .           .                      .                  .                  .                      .                   .                   .           		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
            .           .           .                      .                  .                  .                      .                   .                   .           	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
            .           .           .                      .                  .                  .                      .                   .                   .           			    _M_get_Tp_allocator());
            .           .           .                      .                  .                  .                      .                   .                   .           	    }
            .           .           .                      .                  .                  .                      .                   .                   .           	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
            .           .           .                      .                  .                  .                      .                   .                   .           	  _M_deallocate(this->_M_impl._M_start,
            .           .           .                      .                  .                  .                      .                   .                   .           			this->_M_impl._M_end_of_storage
            .           .           .                      .                  .                  .                      .                   .                   .           			- this->_M_impl._M_start);
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             1 ( 0.00%)         0                  0                      1 ( 0.00%)          0                   0           	  this->_M_impl._M_start = __tmp;
            .           .           .                      .                  .                  .                      .                   .                   .           	  this->_M_impl._M_finish = __tmp + __old_size;
            2 ( 0.00%)  0           0                      0                  0                  0                      1 ( 0.00%)          0                   0           	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
            .           .           .                      .                  .                  .                      .                   .                   .           	}
            .           .           .                      .                  .                  .                      .                   .                   .               }
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               template<typename... _Args>
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus > 201402L
            .           .           .                      .                  .                  .                      .                   .                   .                 typename vector<_Tp, _Alloc>::reference
            .           .           .                      .                  .                  .                      .                   .                   .           #else
            .           .           .                      .                  .                  .                      .                   .                   .                 void
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
   74,097,152 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)             0                  0                  0             46,310,720 ( 0.01%)          0                   0                 vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .                 emplace_back(_Args&&... __args)
            .           .           .                      .                  .                  .                      .                   .                   .                 {
9,525,631,282 ( 0.41%)  3 ( 0.04%)  3 ( 0.04%) 6,462,969,052 ( 1.36%) 1,290,964 ( 0.01%) 1,240,641 ( 0.07%)             0                   0                   0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
            .           .           .                      .                  .                  .                      .                   .                   .           	  {
            .           .           .                      .                  .                  .                      .                   .                   .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
            .           .           .                      .                  .                  .                      .                   .                   .           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
            .           .           .                      .                  .                  .                      .                   .                   .           				     std::forward<_Args>(__args)...);
6,065,063,310 ( 0.26%)  0           0            109,044,000 ( 0.02%)         0                  0          3,084,029,405 ( 0.53%) 13,597,745 ( 0.24%) 13,597,735 (15.71%)  	    ++this->_M_impl._M_finish;
            .           .           .                      .                  .                  .                      .                   .                   .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
            .           .           .                      .                  .                  .                      .                   .                   .           	  }
            .           .           .                      .                  .                  .                      .                   .                   .           	else
   23,230,588 ( 0.00%) 11 ( 0.14%) 11 ( 0.15%)     1,076,149 ( 0.00%) 1,075,915 ( 0.01%)         5 ( 0.00%)     7,076,852 ( 0.00%)          0                   0           	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus > 201402L
            .           .           .                      .                  .                  .                      .                   .                   .           	return back();
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
   74,097,152 ( 0.00%)  0           0             55,572,864 ( 0.01%)         0                  0                      0                   0                   0                 }
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               typename vector<_Tp, _Alloc>::iterator
            .           .           .                      .                  .                  .                      .                   .                   .               vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .               insert(const_iterator __position, const value_type& __x)
            .           .           .                      .                  .                  .                      .                   .                   .           #else
-- line 133 ----------------------------------------
-- line 418 ----------------------------------------
            .           .           .                      .                  .                  .                      .                   .                   .                 *__position = std::forward<_Arg>(__arg);
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .               }
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               template<typename... _Args>
            .           .           .                      .                  .                  .                      .                   .                   .                 void
   78,808,741 ( 0.00%) 16 ( 0.20%) 16 ( 0.22%)    13,448,474 ( 0.00%)    23,024 ( 0.00%)    22,454 ( 0.00%)    43,573,595 ( 0.01%)         56 ( 0.00%)          0                 vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .                 _M_realloc_insert(iterator __position, _Args&&... __args)
            .           .           .                      .                  .                  .                      .                   .                   .           #else
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               void
            .           .           .                      .                  .                  .                      .                   .                   .               vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .               _M_realloc_insert(iterator __position, const _Tp& __x)
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .               {
-- line 434 ----------------------------------------
-- line 441 ----------------------------------------
            .           .           .                      .                  .                  .                      .                   .                   .                 pointer __new_finish(__new_start);
            .           .           .                      .                  .                  .                      .                   .                   .                 __try
            .           .           .                      .                  .                  .                      .                   .                   .           	{
            .           .           .                      .                  .                  .                      .                   .                   .           	  // The order of the three operations is dictated by the C++11
            .           .           .                      .                  .                  .                      .                   .                   .           	  // case, where the moves could alter a new element belonging
            .           .           .                      .                  .                  .                      .                   .                   .           	  // to the existing vector.  This is an issue only for callers
            .           .           .                      .                  .                  .                      .                   .                   .           	  // taking the element by lvalue ref (see last bullet of C++11
            .           .           .                      .                  .                  .                      .                   .                   .           	  // [res.on.arguments]).
    1,076,100 ( 0.00%)  0           0                      0                  0                  0                      0                   0                   0           	  _Alloc_traits::construct(this->_M_impl,
            .           .           .                      .                  .                  .                      .                   .                   .           				   __new_start + __elems_before,
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .           				   std::forward<_Args>(__args)...);
            .           .           .                      .                  .                  .                      .                   .                   .           #else
            .           .           .                      .                  .                  .                      .                   .                   .           				   __x);
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .           	  __new_finish = pointer();
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .           	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
            .           .           .                      .                  .                  .                      .                   .                   .           	    {
            .           .           .                      .                  .                  .                      .                   .                   .           	      __new_finish = _S_relocate(__old_start, __position.base(),
            .           .           .                      .                  .                  .                      .                   .                   .           					 __new_start, _M_get_Tp_allocator());
            .           .           .                      .                  .                  .                      .                   .                   .           
   21,056,516 ( 0.00%)  7 ( 0.09%)  7 ( 0.10%)             0                  0                  0                      0                   0                   0           	      ++__new_finish;
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .           	      __new_finish = _S_relocate(__position.base(), __old_finish,
            .           .           .                      .                  .                  .                      .                   .                   .           					 __new_finish, _M_get_Tp_allocator());
            .           .           .                      .                  .                  .                      .                   .                   .           	    }
            .           .           .                      .                  .                  .                      .                   .                   .           	  else
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .           	    {
            .           .           .                      .                  .                  .                      .                   .                   .           	      __new_finish
-- line 472 ----------------------------------------
-- line 493 ----------------------------------------
            .           .           .                      .                  .                  .                      .                   .                   .           	  __throw_exception_again;
            .           .           .                      .                  .                  .                      .                   .                   .           	}
            .           .           .                      .                  .                  .                      .                   .                   .           #if __cplusplus >= 201103L
            .           .           .                      .                  .                  .                      .                   .                   .                 if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .           	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
            .           .           .                      .                  .                  .                      .                   .                   .                 _GLIBCXX_ASAN_ANNOTATE_REINIT;
            .           .           .                      .                  .                  .                      .                   .                   .                 _M_deallocate(__old_start,
   30,844,870 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)    13,249,638 ( 0.00%)        72 ( 0.00%)        22 ( 0.00%)     8,000,000 ( 0.00%)          0                   0           		    this->_M_impl._M_end_of_storage - __old_start);
   18,488,729 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)     8,706,300 ( 0.00%)         0                  0              7,262,287 ( 0.00%)         30 ( 0.00%)          6 ( 0.00%)        this->_M_impl._M_start = __new_start;
            .           .           .                      .                  .                  .                      .                   .                   .                 this->_M_impl._M_finish = __new_finish;
   53,918,362 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     3,517,601 ( 0.00%)         6 ( 0.00%)         0             18,434,797 ( 0.00%)          0                   0                 this->_M_impl._M_end_of_storage = __new_start + __len;
   58,098,072 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)    50,835,799 ( 0.01%)        61 ( 0.00%)        13 ( 0.00%)             0                   0                   0               }
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               void
            .           .           .                      .                  .                  .                      .                   .                   .               vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .               _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
            .           .           .                      .                  .                  .                      .                   .                   .               {
            .           .           .                      .                  .                  .                      .                   .                   .                 if (__n != 0)
            .           .           .                      .                  .                  .                      .                   .                   .           	{
-- line 513 ----------------------------------------
-- line 682 ----------------------------------------
            .           .           .                      .                  .                  .                      .                   .                   .           	}
            .           .           .                      .                  .                  .                      .                   .                   .               }
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               bool
            .           .           .                      .                  .                  .                      .                   .                   .               vector<_Tp, _Alloc>::
            .           .           .                      .                  .                  .                      .                   .                   .               _M_shrink_to_fit()
            .           .           .                      .                  .                  .                      .                   .                   .               {
            6 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)             1 ( 0.00%)         0                  0                      0                   0                   0                 if (capacity() == size())
            .           .           .                      .                  .                  .                      .                   .                   .           	return false;
            .           .           .                      .                  .                  .                      .                   .                   .                 _GLIBCXX_ASAN_ANNOTATE_REINIT;
            .           .           .                      .                  .                  .                      .                   .                   .                 return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
            .           .           .                      .                  .                  .                      .                   .                   .               }
            .           .           .                      .                  .                  .                      .                   .                   .           #endif
            .           .           .                      .                  .                  .                      .                   .                   .           
            .           .           .                      .                  .                  .                      .                   .                   .             template<typename _Tp, typename _Alloc>
            .           .           .                      .                  .                  .                      .                   .                   .               template<typename _InputIterator>
-- line 698 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_iterator.h
--------------------------------------------------------------------------------
Ir                      I1mr        ILmr        Dr                     D1mr               DLmr           Dw                   D1mw            DLmw       

-- line 999 ----------------------------------------
             .           .           .                      .                  .              .                    .               .          .                 typedef typename __traits_type::reference 	reference;
             .           .           .                      .                  .              .                    .               .          .                 typedef typename __traits_type::pointer   	pointer;
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .           #if __cplusplus > 201703L && __cpp_lib_concepts
             .           .           .                      .                  .              .                    .               .          .                 using iterator_concept = std::__detail::__iter_concept<_Iterator>;
             .           .           .                      .                  .              .                    .               .          .           #endif
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
     2,000,000 ( 0.00%)  0           0                      0                  0              0            2,000,000 ( 0.00%)      0          0                 : _M_current(_Iterator()) { }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 explicit _GLIBCXX20_CONSTEXPR
     5,000,000 ( 0.00%)  0           0              3,000,000 ( 0.00%)         0              0            2,000,000 ( 0.00%)      0          0                 __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
 2,580,011,278 ( 0.11%) 12 ( 0.15%) 12 ( 0.17%) 1,422,482,485 ( 0.30%) 1,316,262 ( 0.01%) 9,977 ( 0.00%) 695,338,469 ( 0.12%) 26,506 ( 0.00%) 0                 : _M_current(__i) { }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 // Allow iterator to const_iterator conversion
             .           .           .                      .                  .              .                    .               .          .                 template<typename _Iter>
             .           .           .                      .                  .              .                    .               .          .                   _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                   __normal_iterator(const __normal_iterator<_Iter,
             .           .           .                      .                  .              .                    .               .          .           			  typename __enable_if<
             .           .           .                      .                  .              .                    .               .          .                 	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
             .           .           .                      .                  .              .                    .               .          .           		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .                   : _M_current(__i.base()) { }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 // Forward iterator requirements
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 reference
             .           .           .                      .                  .              .                    .               .          .                 operator*() const _GLIBCXX_NOEXCEPT
    44,000,000 ( 0.00%)  0           0             44,000,000 ( 0.01%)         0              0                    0               0          0                 { return *_M_current; }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 pointer
             .           .           .                      .                  .              .                    .               .          .                 operator->() const _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .                 { return _M_current; }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 __normal_iterator&
             .           .           .                      .                  .              .                    .               .          .                 operator++() _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .                 {
     1,146,885 ( 0.00%)  0           0                      0                  0              0                    0               0          0           	++_M_current;
             .           .           .                      .                  .              .                    .               .          .           	return *this;
             .           .           .                      .                  .              .                    .               .          .                 }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 __normal_iterator
             .           .           .                      .                  .              .                    .               .          .                 operator++(int) _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .                 { return __normal_iterator(_M_current++); }
             .           .           .                      .                  .              .                    .               .          .           
-- line 1045 ----------------------------------------
-- line 1060 ----------------------------------------
             .           .           .                      .                  .              .                    .               .          .                 // Random access iterator requirements
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 reference
             .           .           .                      .                  .              .                    .               .          .                 operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .                 { return _M_current[__n]; }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 __normal_iterator&
 4,621,903,240 ( 0.20%)  2 ( 0.02%)  2 ( 0.03%) 1,848,761,296 ( 0.39%) 1,999,936 ( 0.02%)     2 ( 0.00%) 924,380,648 ( 0.16%)      0          0                 operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
34,114,042,877 ( 1.46%)  2 ( 0.02%)  2 ( 0.03%) 2,306,614,433 ( 0.48%)         0              0          276,095,162 ( 0.05%)      0          0                 { _M_current += __n; return *this; }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 __normal_iterator
             .           .           .                      .                  .              .                    .               .          .                 operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
     1,260,071 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)             0                  0              0                    0               0          0                 { return __normal_iterator(_M_current + __n); }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 __normal_iterator&
             .           .           .                      .                  .              .                    .               .          .                 operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .                 { _M_current -= __n; return *this; }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .                 _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .                 __normal_iterator
-- line 1082 ----------------------------------------
-- line 1229 ----------------------------------------
             .           .           .                      .                  .              .                    .               .          .               { return __lhs.base() - __rhs.base(); }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .             template<typename _Iterator, typename _Container>
             .           .           .                      .                  .              .                    .               .          .               _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .               inline typename __normal_iterator<_Iterator, _Container>::difference_type
             .           .           .                      .                  .              .                    .               .          .               operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
             .           .           .                      .                  .              .                    .               .          .           	      const __normal_iterator<_Iterator, _Container>& __rhs)
             .           .           .                      .                  .              .                    .               .          .               _GLIBCXX_NOEXCEPT
 1,922,734,279 ( 0.08%)  9 ( 0.11%)  9 ( 0.13%)   463,216,831 ( 0.10%)         0              0                    0               0          0               { return __lhs.base() - __rhs.base(); }
             .           .           .                      .                  .              .                    .               .          .           
             .           .           .                      .                  .              .                    .               .          .             template<typename _Iterator, typename _Container>
             .           .           .                      .                  .              .                    .               .          .               _GLIBCXX20_CONSTEXPR
             .           .           .                      .                  .              .                    .               .          .               inline __normal_iterator<_Iterator, _Container>
             .           .           .                      .                  .              .                    .               .          .               operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
             .           .           .                      .                  .              .                    .               .          .           	      __n, const __normal_iterator<_Iterator, _Container>& __i)
             .           .           .                      .                  .              .                    .               .          .               _GLIBCXX_NOEXCEPT
             .           .           .                      .                  .              .                    .               .          .               { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
-- line 1245 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_pair.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr           DLmr       Dw                     D1mw       DLmw       

-- line 345 ----------------------------------------
            .          .          .                      .              .          .                      .          .          .           
            .          .          .                      .              .          .                      .          .          .                 template<typename _U1, typename _U2, typename
            .          .          .                      .              .          .                      .          .          .           	       enable_if<_PCCP::template
            .          .          .                      .              .          .                      .          .          .           			   _MoveConstructiblePair<_U1, _U2>()
            .          .          .                      .              .          .                      .          .          .           			  && _PCCP::template
            .          .          .                      .              .          .                      .          .          .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
            .          .          .                      .              .          .                      .          .          .                                    bool>::type=true>
            .          .          .                      .              .          .                      .          .          .           	constexpr pair(_U1&& __x, _U2&& __y)
8,543,069,545 ( 0.37%) 0          0          3,417,227,818 ( 0.72%)     0          0          3,417,227,818 ( 0.58%) 0          0           	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
            .          .          .                      .              .          .                      .          .          .           
            .          .          .                      .              .          .                      .          .          .                 template<typename _U1, typename _U2, typename
            .          .          .                      .              .          .                      .          .          .           	       enable_if<_PCCP::template
            .          .          .                      .              .          .                      .          .          .           			   _MoveConstructiblePair<_U1, _U2>()
            .          .          .                      .              .          .                      .          .          .           			  && !_PCCP::template
            .          .          .                      .              .          .                      .          .          .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
            .          .          .                      .              .          .                      .          .          .                                    bool>::type=false>
            .          .          .                      .              .          .                      .          .          .           	explicit constexpr pair(_U1&& __x, _U2&& __y)
-- line 361 ----------------------------------------
-- line 364 ----------------------------------------
            .          .          .                      .              .          .                      .          .          .           
            .          .          .                      .              .          .                      .          .          .                 template<typename _U1, typename _U2, typename
            .          .          .                      .              .          .                      .          .          .           	       enable_if<_PCCFP<_U1, _U2>::template
            .          .          .                      .              .          .                      .          .          .           			   _MoveConstructiblePair<_U1, _U2>()
            .          .          .                      .              .          .                      .          .          .           			  && _PCCFP<_U1, _U2>::template
            .          .          .                      .              .          .                      .          .          .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
            .          .          .                      .              .          .                      .          .          .                                    bool>::type=true>
            .          .          .                      .              .          .                      .          .          .           	constexpr pair(pair<_U1, _U2>&& __p)
    1,147,040 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)     1,147,040 ( 0.00%) 2,054 ( 0.00%) 0                      0          0          0           	: first(std::forward<_U1>(__p.first)),
            .          .          .                      .              .          .                      .          .          .           	  second(std::forward<_U2>(__p.second)) { }
            .          .          .                      .              .          .                      .          .          .           
            .          .          .                      .              .          .                      .          .          .                 template<typename _U1, typename _U2, typename
            .          .          .                      .              .          .                      .          .          .           	       enable_if<_PCCFP<_U1, _U2>::template
            .          .          .                      .              .          .                      .          .          .           			   _MoveConstructiblePair<_U1, _U2>()
            .          .          .                      .              .          .                      .          .          .           			  && !_PCCFP<_U1, _U2>::template
            .          .          .                      .              .          .                      .          .          .           			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
            .          .          .                      .              .          .                      .          .          .                                    bool>::type=false>
-- line 380 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_function.h
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr                 DLmr       Dw          D1mw       DLmw       

-- line 362 ----------------------------------------
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .             /// One of the @link comparison_functors comparison functors@endlink.
            .          .          .                      .                    .          .           .          .          .             template<typename _Tp>
            .          .          .                      .                    .          .           .          .          .               struct equal_to : public binary_function<_Tp, _Tp, bool>
            .          .          .                      .                    .          .           .          .          .               {
            .          .          .                      .                    .          .           .          .          .                 _GLIBCXX14_CONSTEXPR
            .          .          .                      .                    .          .           .          .          .                 bool
            .          .          .                      .                    .          .           .          .          .                 operator()(const _Tp& __x, const _Tp& __y) const
2,505,708,213 ( 0.11%) 0          0          1,910,597,263 ( 0.40%) 547,745,307 ( 5.32%) 2 ( 0.00%)  0          0          0                 { return __x == __y; }
            .          .          .                      .                    .          .           .          .          .               };
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .             /// One of the @link comparison_functors comparison functors@endlink.
            .          .          .                      .                    .          .           .          .          .             template<typename _Tp>
            .          .          .                      .                    .          .           .          .          .               struct not_equal_to : public binary_function<_Tp, _Tp, bool>
            .          .          .                      .                    .          .           .          .          .               {
            .          .          .                      .                    .          .           .          .          .                 _GLIBCXX14_CONSTEXPR
            .          .          .                      .                    .          .           .          .          .                 bool
-- line 378 ----------------------------------------
-- line 391 ----------------------------------------
            .          .          .                      .                    .          .           .          .          .               };
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .             /// One of the @link comparison_functors comparison functors@endlink.
            .          .          .                      .                    .          .           .          .          .             template<typename _Tp>
            .          .          .                      .                    .          .           .          .          .               struct less : public binary_function<_Tp, _Tp, bool>
            .          .          .                      .                    .          .           .          .          .               {
            .          .          .                      .                    .          .           .          .          .                 _GLIBCXX14_CONSTEXPR
            .          .          .                      .                    .          .           .          .          .                 bool
            7 ( 0.00%) 0          0                      0                    0          0           0          0          0                 operator()(const _Tp& __x, const _Tp& __y) const
           46 ( 0.00%) 0          0                     23 ( 0.00%)           0          0           0          0          0                 { return __x < __y; }
            .          .          .                      .                    .          .           .          .          .               };
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .             /// One of the @link comparison_functors comparison functors@endlink.
            .          .          .                      .                    .          .           .          .          .             template<typename _Tp>
            .          .          .                      .                    .          .           .          .          .               struct greater_equal : public binary_function<_Tp, _Tp, bool>
            .          .          .                      .                    .          .           .          .          .               {
            .          .          .                      .                    .          .           .          .          .                 _GLIBCXX14_CONSTEXPR
            .          .          .                      .                    .          .           .          .          .                 bool
-- line 408 ----------------------------------------
-- line 1167 ----------------------------------------
            .          .          .                      .                    .          .           .          .          .               : public unary_function<_Pair, typename _Pair::first_type>
            .          .          .                      .                    .          .           .          .          .               {
            .          .          .                      .                    .          .           .          .          .                 typename _Pair::first_type&
            .          .          .                      .                    .          .           .          .          .                 operator()(_Pair& __x) const
            .          .          .                      .                    .          .           .          .          .                 { return __x.first; }
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .                 const typename _Pair::first_type&
            .          .          .                      .                    .          .           .          .          .                 operator()(const _Pair& __x) const
           63 ( 0.00%) 0          0                      0                    0          0          31 ( 0.00%) 0          0                 { return __x.first; }
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .           #if __cplusplus >= 201103L
            .          .          .                      .                    .          .           .          .          .                 template<typename _Pair2>
            .          .          .                      .                    .          .           .          .          .                   typename _Pair2::first_type&
            .          .          .                      .                    .          .           .          .          .                   operator()(_Pair2& __x) const
            .          .          .                      .                    .          .           .          .          .                   { return __x.first; }
            .          .          .                      .                    .          .           .          .          .           
            .          .          .                      .                    .          .           .          .          .                 template<typename _Pair2>
-- line 1183 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_uninitialized.h
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                   D1mr                DLmr                Dw                   D1mw                DLmw                

-- line 83 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .                 template<typename _InputIterator, typename _ForwardIterator>
            .           .           .                    .                   .                   .                    .                   .                   .                   static _ForwardIterator
            .           .           .                    .                   .                   .                    .                   .                   .                   __uninit_copy(_InputIterator __first, _InputIterator __last,
            .           .           .                    .                   .                   .                    .                   .                   .           		      _ForwardIterator __result)
            .           .           .                    .                   .                   .                    .                   .                   .                   {
            .           .           .                    .                   .                   .                    .                   .                   .           	  _ForwardIterator __cur = __result;
            .           .           .                    .                   .                   .                    .                   .                   .           	  __try
            .           .           .                    .                   .                   .                    .                   .                   .           	    {
6,857,016,957 ( 0.29%)  2 ( 0.02%)  2 ( 0.03%)   1,173,392 ( 0.00%)      9,258 ( 0.00%)      8,881 ( 0.00%)   2,293,770 ( 0.00%)     17,317 ( 0.00%)         43 ( 0.00%)  	      for (; __first != __last; ++__first, (void)++__cur)
            .           .           .                    .                   .                   .                    .                   .                   .           		std::_Construct(std::__addressof(*__cur), *__first);
            .           .           .                    .                   .                   .                    .                   .                   .           	      return __cur;
            .           .           .                    .                   .                   .                    .                   .                   .           	    }
            .           .           .                    .                   .                   .                    .                   .                   .           	  __catch(...)
            .           .           .                    .                   .                   .                    .                   .                   .           	    {
            .           .           .                    .                   .                   .                    .                   .                   .           	      std::_Destroy(__result, __cur);
            .           .           .                    .                   .                   .                    .                   .                   .           	      __throw_exception_again;
            .           .           .                    .                   .                   .                    .                   .                   .           	    }
-- line 99 ----------------------------------------
-- line 100 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .           	}
            .           .           .                    .                   .                   .                    .                   .                   .               };
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             template<>
            .           .           .                    .                   .                   .                    .                   .                   .               struct __uninitialized_copy<true>
            .           .           .                    .                   .                   .                    .                   .                   .               {
            .           .           .                    .                   .                   .                    .                   .                   .                 template<typename _InputIterator, typename _ForwardIterator>
            .           .           .                    .                   .                   .                    .                   .                   .                   static _ForwardIterator
    3,000,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                   0                   0            3,000,000 ( 0.00%)    999,973 ( 0.02%)          1 ( 0.00%)          __uninit_copy(_InputIterator __first, _InputIterator __last,
            .           .           .                    .                   .                   .                    .                   .                   .           		      _ForwardIterator __result)
            .           .           .                    .                   .                   .                    .                   .                   .                   { return std::copy(__first, __last, __result); }
            .           .           .                    .                   .                   .                    .                   .                   .               };
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             /// @endcond
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             /**
            .           .           .                    .                   .                   .                    .                   .                   .              *  @brief Copies the range [first,last) into result.
-- line 116 ----------------------------------------
-- line 118 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .              *  @param  __last   An input iterator.
            .           .           .                    .                   .                   .                    .                   .                   .              *  @param  __result An output iterator.
            .           .           .                    .                   .                   .                    .                   .                   .              *  @return   __result + (__first - __last)
            .           .           .                    .                   .                   .                    .                   .                   .              *
            .           .           .                    .                   .                   .                    .                   .                   .              *  Like copy(), but does not require an initialized output range.
            .           .           .                    .                   .                   .                    .                   .                   .             */
            .           .           .                    .                   .                   .                    .                   .                   .             template<typename _InputIterator, typename _ForwardIterator>
            .           .           .                    .                   .                   .                    .                   .                   .               inline _ForwardIterator
    3,000,000 ( 0.00%)  0           0                    0                   0                   0            3,000,000 ( 0.00%)    999,980 ( 0.02%)          1 ( 0.00%)      uninitialized_copy(_InputIterator __first, _InputIterator __last,
            .           .           .                    .                   .                   .                    .                   .                   .           		       _ForwardIterator __result)
            .           .           .                    .                   .                   .                    .                   .                   .               {
            .           .           .                    .                   .                   .                    .                   .                   .                 typedef typename iterator_traits<_InputIterator>::value_type
            .           .           .                    .                   .                   .                    .                   .                   .           	_ValueType1;
            .           .           .                    .                   .                   .                    .                   .                   .                 typedef typename iterator_traits<_ForwardIterator>::value_type
            .           .           .                    .                   .                   .                    .                   .                   .           	_ValueType2;
            .           .           .                    .                   .                   .                    .                   .                   .           #if __cplusplus < 201103L
            .           .           .                    .                   .                   .                    .                   .                   .                 const bool __assignable = true;
-- line 134 ----------------------------------------
-- line 323 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .           	{
            .           .           .                    .                   .                   .                    .                   .                   .           	  std::_Destroy(__result, __cur, __alloc);
            .           .           .                    .                   .                   .                    .                   .                   .           	  __throw_exception_again;
            .           .           .                    .                   .                   .                    .                   .                   .           	}
            .           .           .                    .                   .                   .                    .                   .                   .               }
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
            .           .           .                    .                   .                   .                    .                   .                   .               inline _ForwardIterator
    3,000,000 ( 0.00%)  0           0                    0                   0                   0            3,000,000 ( 0.00%)    999,988 ( 0.02%)          1 ( 0.00%)      __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
            .           .           .                    .                   .                   .                    .                   .                   .           			   _ForwardIterator __result, allocator<_Tp>&)
            .           .           .                    .                   .                   .                    .                   .                   .               { return std::uninitialized_copy(__first, __last, __result); }
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             template<typename _InputIterator, typename _ForwardIterator,
            .           .           .                    .                   .                   .                    .                   .                   .           	   typename _Allocator>
            .           .           .                    .                   .                   .                    .                   .                   .               inline _ForwardIterator
            .           .           .                    .                   .                   .                    .                   .                   .               __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
            .           .           .                    .                   .                   .                    .                   .                   .           			   _ForwardIterator __result, _Allocator& __alloc)
-- line 339 ----------------------------------------
-- line 594 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .                   static _ForwardIterator
            .           .           .                    .                   .                   .                    .                   .                   .                   __uninit_default_n(_ForwardIterator __first, _Size __n)
            .           .           .                    .                   .                   .                    .                   .                   .                   {
            .           .           .                    .                   .                   .                    .                   .                   .           	  if (__n > 0)
            .           .           .                    .                   .                   .                    .                   .                   .           	    {
            .           .           .                    .                   .                   .                    .                   .                   .           	      typename iterator_traits<_ForwardIterator>::value_type* __val
            .           .           .                    .                   .                   .                    .                   .                   .           		= std::__addressof(*__first);
            .           .           .                    .                   .                   .                    .                   .                   .           	      std::_Construct(__val);
            3 ( 0.00%)  0           0                    0                   0                   0                    0                   0                   0           	      ++__first;
            .           .           .                    .                   .                   .                    .                   .                   .           	      __first = std::fill_n(__first, __n - 1, *__val);
            .           .           .                    .                   .                   .                    .                   .                   .           	    }
            .           .           .                    .                   .                   .                    .                   .                   .           	  return __first;
            .           .           .                    .                   .                   .                    .                   .                   .           	}
            .           .           .                    .                   .                   .                    .                   .                   .               };
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             // __uninitialized_default
            .           .           .                    .                   .                   .                    .                   .                   .             // Fills [first, last) with value-initialized value_types.
-- line 610 ----------------------------------------
-- line 998 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .             // This class may be specialized for specific types.
            .           .           .                    .                   .                   .                    .                   .                   .             // Also known as is_trivially_relocatable.
            .           .           .                    .                   .                   .                    .                   .                   .             template<typename _Tp, typename = void>
            .           .           .                    .                   .                   .                    .                   .                   .               struct __is_bitwise_relocatable
            .           .           .                    .                   .                   .                    .                   .                   .               : is_trivial<_Tp> { };
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             template <typename _Tp, typename _Up>
            .           .           .                    .                   .                   .                    .                   .                   .               inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
           12 ( 0.00%)  0           0                    0                   0                   0                    0                   0                   0               __relocate_a_1(_Tp* __first, _Tp* __last,
            .           .           .                    .                   .                   .                    .                   .                   .           		   _Tp* __result, allocator<_Up>&) noexcept
            .           .           .                    .                   .                   .                    .                   .                   .               {
    6,186,300 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)          0                   0                   70 ( 0.00%)         31 ( 0.00%)         21 ( 0.00%)        ptrdiff_t __count = __last - __first;
   37,089,778 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)          64 ( 0.00%)         14 ( 0.00%)          5 ( 0.00%)           0                   0                   0                 if (__count > 0)
   35,010,849 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)   8,000,000 ( 0.00%)          0                   0           13,332,614 ( 0.00%)          0                   0           	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
   24,744,632 ( 0.00%)  4 ( 0.05%)  4 ( 0.06%)           0                   0                   0            6,186,158 ( 0.00%)          0                   0                 return __result + __count;
            .           .           .                    .                   .                   .                    .                   .                   .               }
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             template <typename _InputIterator, typename _ForwardIterator,
            .           .           .                    .                   .                   .                    .                   .                   .           	    typename _Allocator>
            .           .           .                    .                   .                   .                    .                   .                   .               inline _ForwardIterator
            .           .           .                    .                   .                   .                    .                   .                   .               __relocate_a_1(_InputIterator __first, _InputIterator __last,
            .           .           .                    .                   .                   .                    .                   .                   .           		   _ForwardIterator __result, _Allocator& __alloc)
            .           .           .                    .                   .                   .                    .                   .                   .               noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
-- line 1020 ----------------------------------------
-- line 1022 ----------------------------------------
            .           .           .                    .                   .                   .                    .                   .                   .           					       __alloc)))
            .           .           .                    .                   .                   .                    .                   .                   .               {
            .           .           .                    .                   .                   .                    .                   .                   .                 typedef typename iterator_traits<_InputIterator>::value_type
            .           .           .                    .                   .                   .                    .                   .                   .           	_ValueType;
            .           .           .                    .                   .                   .                    .                   .                   .                 typedef typename iterator_traits<_ForwardIterator>::value_type
            .           .           .                    .                   .                   .                    .                   .                   .           	_ValueType2;
            .           .           .                    .                   .                   .                    .                   .                   .                 static_assert(std::is_same<_ValueType, _ValueType2>::value,
            .           .           .                    .                   .                   .                    .                   .                   .           	  "relocation is only possible for values of the same type");
      179,697 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                   0                   0                    0                   0                   0                 _ForwardIterator __cur = __result;
  120,223,759 ( 0.01%) 21 ( 0.26%) 21 ( 0.29%) 108,792,303 ( 0.02%) 13,598,582 ( 0.13%) 13,386,248 ( 0.80%) 108,792,250 ( 0.02%) 13,599,027 ( 0.24%) 13,599,019 (15.71%)        for (; __first != __last; ++__first, (void)++__cur)
            .           .           .                    .                   .                   .                    .                   .                   .           	std::__relocate_object_a(std::__addressof(*__cur),
            .           .           .                    .                   .                   .                    .                   .                   .           				 std::__addressof(*__first), __alloc);
            .           .           .                    .                   .                   .                    .                   .                   .                 return __cur;
            .           .           .                    .                   .                   .                    .                   .                   .               }
            .           .           .                    .                   .                   .                    .                   .                   .           
            .           .           .                    .                   .                   .                    .                   .                   .             template <typename _InputIterator, typename _ForwardIterator,
            .           .           .                    .                   .                   .                    .                   .                   .           	    typename _Allocator>
            .           .           .                    .                   .                   .                    .                   .                   .               inline _ForwardIterator
-- line 1039 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/alphabet/nucleotide/nucleotide_base.hpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr                DLmr                Dw                     D1mw                DLmw            

-- line 77 ----------------------------------------
            .          .          .                      .                   .                   .                      .                   .               .                * \details
            .          .          .                      .                   .                   .                      .                   .               .                * \experimentalapi{Experimental since version 3.1.}
            .          .          .                      .                   .                   .                      .                   .               .                */
            .          .          .                      .                   .                   .                      .                   .               .               template <typename other_nucl_type>
            .          .          .                      .                   .                   .                      .                   .               .                   requires (!std::same_as<nucleotide_base, other_nucl_type>)
            .          .          .                      .                   .                   .                      .                   .               .                         && (!std::same_as<derived_type, other_nucl_type>) && nucleotide_alphabet<other_nucl_type>
            .          .          .                      .                   .                   .                      .                   .               .               explicit constexpr nucleotide_base(other_nucl_type const & other) noexcept
            .          .          .                      .                   .                   .                      .                   .               .               {
3,417,970,014 ( 0.15%) 1 ( 0.01%) 1 ( 0.01%) 1,708,985,007 ( 0.36%)     52,875 ( 0.00%)         32 ( 0.00%) 1,708,985,007 ( 0.29%) 26,683,450 ( 0.47%) 65,803 ( 0.08%)          static_cast<derived_type &>(*this) =
1,708,985,007 ( 0.07%) 0          0          1,708,985,007 ( 0.36%) 26,688,583 ( 0.26%) 24,344,048 ( 1.46%)             0                   0               0                       detail::convert_through_char_representation<other_nucl_type, derived_type>[seqan3::to_rank(other)];
            .          .          .                      .                   .                   .                      .                   .               .               }
            .          .          .                      .                   .                   .                      .                   .               .               //!\}
            .          .          .                      .                   .                   .                      .                   .               .           
            .          .          .                      .                   .                   .                      .                   .               .               /*!\name Read functions
            .          .          .                      .                   .                   .                      .                   .               .                * \{
            .          .          .                      .                   .                   .                      .                   .               .                */
            .          .          .                      .                   .                   .                      .                   .               .           
            .          .          .                      .                   .                   .                      .                   .               .               /*!\brief Return the complement of the letter.
-- line 94 ----------------------------------------
-- line 133 ----------------------------------------
            .          .          .                      .                   .                   .                      .                   .               .                * ###Exceptions
            .          .          .                      .                   .                   .                      .                   .               .                *
            .          .          .                      .                   .                   .                      .                   .               .                * Guaranteed not to throw.
            .          .          .                      .                   .                   .                      .                   .               .                *
            .          .          .                      .                   .                   .                      .                   .               .                * \experimentalapi{Experimental since version 3.1.}
            .          .          .                      .                   .                   .                      .                   .               .                */
            .          .          .                      .                   .                   .                      .                   .               .               static constexpr bool char_is_valid(char_type const c) noexcept
            .          .          .                      .                   .                   .                      .                   .               .               {
          932 ( 0.00%) 0          0                      0                   0                   0                      0                   0               0                   return valid_char_table[static_cast<uint8_t>(c)];
            .          .          .                      .                   .                   .                      .                   .               .               }
            .          .          .                      .                   .                   .                      .                   .               .           
            .          .          .                      .                   .                   .                      .                   .               .           private:
            .          .          .                      .                   .                   .                      .                   .               .               // clang-format off
            .          .          .                      .                   .                   .                      .                   .               .               //!\brief Implementation of seqan3::nucleotide_base::char_is_valid().
            .          .          .                      .                   .                   .                      .                   .               .               static constexpr std::array<bool, 256> valid_char_table
            .          .          .                      .                   .                   .                      .                   .               .               {
            .          .          .                      .                   .                   .                      .                   .               .                   []() constexpr {
-- line 149 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/search/views/kmer_hash.hpp
--------------------------------------------------------------------------------
Ir                       I1mr        ILmr        Dr                      D1mr                DLmr                Dw                     D1mw               DLmw       

-- line 82 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .                * \throws std::invalid_argument if hashes resulting from the shape/alphabet combination cannot be represented in
              .           .           .                       .                   .                   .                      .                  .          .                *         `uint64_t`, i.e. \f$s>\frac{64}{\log_2\sigma}\f$ with shape size \f$s\f$ and alphabet size \f$\sigma\f$.
              .           .           .                       .                   .                   .                      .                  .          .                */
              .           .           .                       .                   .                   .                      .                  .          .               template <typename rng_t>
              .           .           .                       .                   .                   .                      .                  .          .                   requires (!std::same_as<std::remove_cvref_t<rng_t>, kmer_hash_view>) && std::ranges::viewable_range<rng_t>
              .           .           .                       .                   .                   .                      .                  .          .                             && std::constructible_from<urng_t, std::ranges::ref_view<std::remove_reference_t<rng_t>>>
              .           .           .                       .                   .                   .                      .                  .          .               explicit kmer_hash_view(rng_t && urange_, shape const & s_) :
              .           .           .                       .                   .                   .                      .                  .          .                   urange{std::views::all(std::forward<rng_t>(urange_))},
      2,000,000 ( 0.00%)  0           0                       0                   0                   0              2,000,000 ( 0.00%)   999,968 ( 0.02%) 1 ( 0.00%)          shape_{s_}
              .           .           .                       .                   .                   .                      .                  .          .               {
      4,053,014 ( 0.00%)  0           0                       0                   0                   0                      0                  0          0                   if (shape_.count() > (64 / std::log2(alphabet_size<std::ranges::range_reference_t<urng_t>>)))
              .           .           .                       .                   .                   .                      .                  .          .                   {
              .           .           .                       .                   .                   .                      .                  .          .                       throw std::invalid_argument{"The chosen shape/alphabet combination is not valid. "
              .           .           .                       .                   .                   .                      .                  .          .                                                   "The alphabet or shape size must be reduced."};
              .           .           .                       .                   .                   .                      .                  .          .                   }
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .               //!\}
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               /*!\name Iterators
-- line 100 ----------------------------------------
-- line 110 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .                * Constant.
              .           .           .                       .                   .                   .                      .                  .          .                *
              .           .           .                       .                   .                   .                      .                  .          .                * ### Exceptions
              .           .           .                       .                   .                   .                      .                  .          .                *
              .           .           .                       .                   .                   .                      .                  .          .                * No-throw guarantee.
              .           .           .                       .                   .                   .                      .                  .          .                */
              .           .           .                       .                   .                   .                      .                  .          .               auto begin() noexcept
              .           .           .                       .                   .                   .                      .                  .          .               {
     20,000,000 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)     12,000,000 ( 0.00%)          0                   0              4,000,000 ( 0.00%)   999,968 ( 0.02%) 1 ( 0.00%)          return basic_iterator<false>{std::ranges::begin(urange), std::ranges::end(urange), shape_};
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\copydoc begin()
              .           .           .                       .                   .                   .                      .                  .          .               auto begin() const noexcept
              .           .           .                       .                   .                   .                      .                  .          .                   requires const_iterable_range<urng_t>
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   return basic_iterator<true>{std::ranges::cbegin(urange), std::ranges::cend(urange), shape_};
              .           .           .                       .                   .                   .                      .                  .          .               }
-- line 126 ----------------------------------------
-- line 139 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .                * ### Exceptions
              .           .           .                       .                   .                   .                      .                  .          .                *
              .           .           .                       .                   .                   .                      .                  .          .                * No-throw guarantee.
              .           .           .                       .                   .                   .                      .                  .          .                */
              .           .           .                       .                   .                   .                      .                  .          .               auto end() noexcept
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   // Assigning the end iterator to the text_right iterator of the basic_iterator only works for common ranges.
              .           .           .                       .                   .                   .                      .                  .          .                   if constexpr (std::ranges::common_range<urng_t>)
     12,000,000 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)      6,000,000 ( 0.00%)          0                   0              2,000,000 ( 0.00%)         0          0                       return basic_iterator<false>{std::ranges::begin(urange), std::ranges::end(urange), shape_, true};
              .           .           .                       .                   .                   .                      .                  .          .                   else
              .           .           .                       .                   .                   .                      .                  .          .                       return std::ranges::end(urange);
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\copydoc end()
              .           .           .                       .                   .                   .                      .                  .          .               auto end() const noexcept
              .           .           .                       .                   .                   .                      .                  .          .                   requires const_iterable_range<urng_t>
              .           .           .                       .                   .                   .                      .                  .          .               {
-- line 155 ----------------------------------------
-- line 163 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               /*!\brief Returns the size of the range, if the underlying range is a std::ranges::sized_range.
              .           .           .                       .                   .                   .                      .                  .          .                * \returns Size of range.
              .           .           .                       .                   .                   .                      .                  .          .                */
              .           .           .                       .                   .                   .                      .                  .          .               auto size()
              .           .           .                       .                   .                   .                      .                  .          .                   requires std::ranges::sized_range<urng_t>
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   using size_type = std::ranges::range_size_t<urng_t>;
      9,000,000 ( 0.00%)  0           0                       0                   0                   0                      0                  0          0                   return std::max<size_type>(std::ranges::size(urange) + 1, shape_.size()) - shape_.size();
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\copydoc size()
              .           .           .                       .                   .                   .                      .                  .          .               auto size() const
              .           .           .                       .                   .                   .                      .                  .          .                   requires std::ranges::sized_range<urng_t const>
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   using size_type = std::ranges::range_size_t<urng_t const>;
              .           .           .                       .                   .                   .                      .                  .          .                   return std::max<size_type>(std::ranges::size(urange) + 1, shape_.size()) - shape_.size();
-- line 179 ----------------------------------------
-- line 266 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .               * /param[in] s_       The seqan3::shape that determines which positions participate in hashing.
              .           .           .                       .                   .                   .                      .                  .          .               *
              .           .           .                       .                   .                   .                      .                  .          .               * \details
              .           .           .                       .                   .                   .                      .                  .          .               *
              .           .           .                       .                   .                   .                      .                  .          .               * ### Complexity
              .           .           .                       .                   .                   .                      .                  .          .               *
              .           .           .                       .                   .                   .                      .                  .          .               * Linear in size of shape.
              .           .           .                       .                   .                   .                      .                  .          .               */
     10,000,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)              0                   0                   0              2,000,000 ( 0.00%)         0          0               basic_iterator(it_t it_start, sentinel_t it_end, shape s_) :
      2,000,000 ( 0.00%)  0           0                       0                   0                   0              2,000,000 ( 0.00%)         0          0                   shape_{s_},
      2,000,000 ( 0.00%)  0           0                       0                   0                   0              2,000,000 ( 0.00%)         0          0                   text_left{it_start},
     12,159,042 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         26,507 ( 0.00%)          0                   0              4,053,014 ( 0.00%)         0          0                   text_right{std::ranges::next(text_left, shape_.size() - 1, it_end)}
              .           .           .                       .                   .                   .                      .                  .          .               {
     24,053,014 ( 0.00%)  0           0              10,000,000 ( 0.00%)          0                   0                      0                  0          0                   assert(std::ranges::size(shape_) > 0);
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .                   // shape size = 3
              .           .           .                       .                   .                   .                      .                  .          .                   // Text:      1 2 3 4 5 6 7 8 9
              .           .           .                       .                   .                   .                      .                  .          .                   // text_left: ^
              .           .           .                       .                   .                   .                      .                  .          .                   // text_right:    ^
              .           .           .                       .                   .                   .                      .                  .          .                   // distance(text_left, text_right) = 2
     38,106,028 ( 0.00%)  3 ( 0.04%)  3 ( 0.04%)         26,507 ( 0.00%)          0                   0                      0                  0          0                   if (shape_.size() <= std::ranges::distance(text_left, text_right) + 1)
              .           .           .                       .                   .                   .                      .                  .          .                   {
      2,000,000 ( 0.00%)  0           0                       0                   0                   0              2,000,000 ( 0.00%)         0          0                       roll_factor = pow(sigma, static_cast<size_t>(std::ranges::size(shape_) - 1));
              .           .           .                       .                   .                   .                      .                  .          .                       hash_full();
              .           .           .                       .                   .                   .                      .                  .          .                   }
      4,000,000 ( 0.00%)  0           0               4,000,000 ( 0.00%)          0                   0                      0                  0          0               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               /*!\brief Construct from a given iterator on the text and a seqan3::shape.
              .           .           .                       .                   .                   .                      .                  .          .               * /param[in] it_start Iterator pointing to the first position of the text.
              .           .           .                       .                   .                   .                      .                  .          .               * /param[in] it_end   Sentinel pointing to the end of the text.
              .           .           .                       .                   .                   .                      .                  .          .               * /param[in] s_       The seqan3::shape that determines which positions participate in hashing.
              .           .           .                       .                   .                   .                      .                  .          .               * /param[in] is_end   Indicates that this iterator should point to the end of the text.
              .           .           .                       .                   .                   .                      .                  .          .               *
              .           .           .                       .                   .                   .                      .                  .          .               * \details
-- line 299 ----------------------------------------
-- line 308 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .               * Another difference to the other constructor is that we need to do some work to determine the position of
              .           .           .                       .                   .                   .                      .                  .          .               * the text_left iterator. Note that we use `std::ranges::next` instead of `std::ranges::prev` because the latter
              .           .           .                       .                   .                   .                      .                  .          .               * only works for bidirectional ranges.    *
              .           .           .                       .                   .                   .                      .                  .          .               *
              .           .           .                       .                   .                   .                      .                  .          .               * ### Complexity
              .           .           .                       .                   .                   .                      .                  .          .               *
              .           .           .                       .                   .                   .                      .                  .          .               * Linear in size of shape.
              .           .           .                       .                   .                   .                      .                  .          .               */
     14,000,000 ( 0.00%)  2 ( 0.02%)  2 ( 0.03%)              0                   0                   0              8,000,000 ( 0.00%) 1,999,949 ( 0.04%) 3 ( 0.00%)      basic_iterator(it_t it_start, sentinel_t it_end, shape s_, bool SEQAN3_DOXYGEN_ONLY(is_end)) : shape_{s_}
              .           .           .                       .                   .                   .                      .                  .          .               {
  1,852,761,296 ( 0.08%)  1 ( 0.01%)  1 ( 0.01%)    462,190,324 ( 0.10%)          0                   0            462,190,324 ( 0.08%)         0          0                   assert(std::ranges::size(shape_) > 0);
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .                   auto urange_size = std::ranges::distance(it_start, it_end);
  3,249,464,803 ( 0.14%)  2 ( 0.02%)  2 ( 0.03%)    462,190,324 ( 0.10%)          0                   0                      0                  0          0                   auto step = (shape_.size() > urange_size + 1) ? 0 : urange_size - shape_.size() + 1;
      2,000,000 ( 0.00%)  0           0                       0                   0                   0              2,000,000 ( 0.00%)         0          0                   text_left = std::ranges::next(it_start, step, it_end);
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .                   // shape size = 3
              .           .           .                       .                   .                   .                      .                  .          .                   // Text:      1 2 3 4 5 6 7 8 9
              .           .           .                       .                   .                   .                      .                  .          .                   // text_left: ^
              .           .           .                       .                   .                   .                      .                  .          .                   // text_right:    ^
              .           .           .                       .                   .                   .                      .                  .          .                   // distance(text_left, text_right) = 2
  1,392,677,000 ( 0.06%)  1 ( 0.01%)  1 ( 0.01%)              0                   0                   0                      0                  0          0                   if (shape_.size() <= std::ranges::distance(text_left, it_end) + 1)
              .           .           .                       .                   .                   .                      .                  .          .                   {
  1,856,814,310 ( 0.08%)  3 ( 0.04%)  3 ( 0.04%)    462,216,831 ( 0.10%)          0                   0            464,190,324 ( 0.08%)         0          0                       roll_factor = pow(sigma, static_cast<size_t>(std::ranges::size(shape_) - 1));
              .           .           .                       .                   .                   .                      .                  .          .                       hash_full();
              .           .           .                       .                   .                   .                      .                  .          .                   }
              .           .           .                       .                   .                   .                      .                  .          .           
      2,000,000 ( 0.00%)  0           0                       0                   0                   0              2,000,000 ( 0.00%)         0          0                   text_right = it_end;
      8,000,000 ( 0.00%)  0           0               6,000,000 ( 0.00%)          0                   0                      0                  0          0               }
              .           .           .                       .                   .                   .                      .                  .          .               //!\}
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\anchor basic_iterator_comparison_kmer_hash
              .           .           .                       .                   .                   .                      .                  .          .               //!\name Comparison operators
              .           .           .                       .                   .                   .                      .                  .          .               //!\{
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Compare to iterator on text.
              .           .           .                       .                   .                   .                      .                  .          .               friend bool operator==(basic_iterator const & lhs, sentinel_t const & rhs) noexcept
-- line 344 ----------------------------------------
-- line 532 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .                   requires std::random_access_iterator<it_t>
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   return *(*this + n);
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Return the hash value.
              .           .           .                       .                   .                   .                      .                  .          .               value_type operator*() const noexcept
              .           .           .                       .                   .                   .                      .                  .          .               {
  8,468,652,924 ( 0.36%)  1 ( 0.01%)  1 ( 0.01%)  2,525,712,553 ( 0.53%) 27,846,409 ( 0.27%) 26,685,185 ( 1.60%) 1,708,613,909 ( 0.29%)         0          0                   return hash_value + to_rank(*text_right);
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .           private:
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief The alphabet type of the passed iterator.
              .           .           .                       .                   .                   .                      .                  .          .               using alphabet_t = std::iter_value_t<it_t>;
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief The alphabet size.
              .           .           .                       .                   .                   .                      .                  .          .               static constexpr auto const sigma{alphabet_size<alphabet_t>};
-- line 548 ----------------------------------------
-- line 560 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .               it_t text_left;
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Iterator to the rightmost position of the k-mer.
              .           .           .                       .                   .                   .                      .                  .          .               it_t text_right;
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Increments iterator by 1.
              .           .           .                       .                   .                   .                      .                  .          .               void hash_forward()
              .           .           .                       .                   .                   .                      .                  .          .               {
  6,393,664,763 ( 0.27%)  2 ( 0.02%)  2 ( 0.03%)  4,108,047,383 ( 0.86%)        584 ( 0.00%)          0                      0                  0          0                   if (shape_.all())
              .           .           .                       .                   .                   .                      .                  .          .                   {
              .           .           .                       .                   .                   .                      .                  .          .                       hash_roll_forward();
              .           .           .                       .                   .                   .                      .                  .          .                   }
              .           .           .                       .                   .                   .                      .                  .          .                   else
              .           .           .                       .                   .                   .                      .                  .          .                   {
              .           .           .                       .                   .                   .                      .                  .          .                       std::ranges::advance(text_left, 1);
              .           .           .                       .                   .                   .                      .                  .          .                       hash_full();
              .           .           .                       .                   .                   .                      .                  .          .                   }
-- line 576 ----------------------------------------
-- line 612 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   std::ranges::advance(text_left, -skip);
              .           .           .                       .                   .                   .                      .                  .          .                   hash_full();
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Calculates a hash value by explicitly looking at each position.
              .           .           .                       .                   .                   .                      .                  .          .               void hash_full()
              .           .           .                       .                   .                   .                      .                  .          .               {
    239,148,176 ( 0.01%)  0           0               4,026,507 ( 0.00%)          0                   0              4,000,000 ( 0.00%)         0          0                   text_right = text_left;
  2,290,617,348 ( 0.10%)  1 ( 0.01%)  1 ( 0.01%)              0                   0                   0              4,000,000 ( 0.00%)         0          0                   hash_value = 0;
              .           .           .                       .                   .                   .                      .                  .          .           
118,253,236,916 ( 5.08%) 12 ( 0.15%) 12 ( 0.17%)  2,417,031,930 ( 0.51%)          0                   0              5,000,000 ( 0.00%)   999,968 ( 0.02%) 1 ( 0.00%)          for (size_t i{0}; i < shape_.size() - 1u; ++i)
              .           .           .                       .                   .                   .                      .                  .          .                   {
121,808,016,020 ( 5.23%)  2 ( 0.02%)  2 ( 0.03%) 30,452,004,005 ( 6.39%)     27,077 ( 0.00%)     26,129 ( 0.00%)             0                  0          0                       hash_value += shape_[i] * to_rank(*text_right);
 91,400,012,015 ( 3.92%)  2 ( 0.02%)  2 ( 0.03%)              0                   0                   0             44,000,000 ( 0.01%)         0          0                       hash_value *= shape_[i] ? sigma : 1;
              .           .           .                       .                   .                   .                      .                  .          .                       std::ranges::advance(text_right, 1);
              .           .           .                       .                   .                   .                      .                  .          .                   }
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Calculates the next hash value via rolling hash.
              .           .           .                       .                   .                   .                      .                  .          .               void hash_roll_forward()
              .           .           .                       .                   .                   .                      .                  .          .               {
              .           .           .                       .                   .                   .                      .                  .          .                   hash_value -= to_rank(*(text_left)) * roll_factor;
-- line 634 ----------------------------------------
-- line 665 ----------------------------------------
              .           .           .                       .                   .                   .                      .                  .          .           //![adaptor_def]
              .           .           .                       .                   .                   .                      .                  .          .           //!\brief views::kmer_hash's range adaptor object type (non-closure).
              .           .           .                       .                   .                   .                      .                  .          .           //!\ingroup search_views
              .           .           .                       .                   .                   .                      .                  .          .           struct kmer_hash_fn
              .           .           .                       .                   .                   .                      .                  .          .           {
              .           .           .                       .                   .                   .                      .                  .          .               //!\brief Store the shape and return a range adaptor closure object.
              .           .           .                       .                   .                   .                      .                  .          .               constexpr auto operator()(shape const & shape_) const
              .           .           .                       .                   .                   .                      .                  .          .               {
      2,185,549 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)      2,053,014 ( 0.00%)     26,508 ( 0.00%)          1 ( 0.00%)        53,014 ( 0.00%)    26,506 ( 0.00%) 0                   return adaptor_from_functor{*this, shape_};
              .           .           .                       .                   .                   .                      .                  .          .               }
              .           .           .                       .                   .                   .                      .                  .          .           
              .           .           .                       .                   .                   .                      .                  .          .               /*!\brief            Call the view's constructor with the underlying view and a seqan3::shape as argument.
              .           .           .                       .                   .                   .                      .                  .          .                * \param[in] urange The input range to process. Must model std::ranges::viewable_range and the reference type
              .           .           .                       .                   .                   .                      .                  .          .                *                   of the range must model seqan3::semialphabet.
              .           .           .                       .                   .                   .                      .                  .          .                * \param[in] shape_ The seqan3::shape to use for hashing.
              .           .           .                       .                   .                   .                      .                  .          .                * \throws std::invalid_argument if resulting hash values would be too big for a 64 bit integer.
              .           .           .                       .                   .                   .                      .                  .          .                * \returns          A range of converted elements.
-- line 681 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/tuple
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                     D1mr               DLmr            Dw                  D1mw            DLmw            

-- line 116 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .           	{ }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 template<typename _Alloc, typename _UHead>
            .          .          .                      .                  .               .                   .               .               .           	_GLIBCXX20_CONSTEXPR
            .          .          .                      .                  .               .                   .               .               .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
            .          .          .                      .                  .               .                   .               .               .           	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 static constexpr _Head&
           37 ( 0.00%) 0          0                      0                  0               0                   0               0               0                 _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 static constexpr const _Head&
            .          .          .                      .                  .               .                   .               .               .                 _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 [[__no_unique_address__]] _Head _M_head_impl;
            .          .          .                      .                  .               .                   .               .               .               };
            .          .          .                      .                  .               .                   .               .               .           #else
            .          .          .                      .                  .               .                   .               .               .             template<size_t _Idx, typename _Head>
-- line 132 ----------------------------------------
-- line 182 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .                 _M_head(const _Head_base& __b) noexcept { return __b; }
            .          .          .                      .                  .               .                   .               .               .               };
            .          .          .                      .                  .               .                   .               .               .           #endif
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .             template<size_t _Idx, typename _Head>
            .          .          .                      .                  .               .                   .               .               .               struct _Head_base<_Idx, _Head, false>
            .          .          .                      .                  .               .                   .               .               .               {
            .          .          .                      .                  .               .                   .               .               .                 constexpr _Head_base()
            3 ( 0.00%) 0          0                      0                  0               0                   3 ( 0.00%)      0               0                 : _M_head_impl() { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 constexpr _Head_base(const _Head& __h)
            .          .          .                      .                  .               .                   .               .               .                 : _M_head_impl(__h) { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 constexpr _Head_base(const _Head_base&) = default;
            .          .          .                      .                  .               .                   .               .               .                 constexpr _Head_base(_Head_base&&) = default;
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 template<typename _UHead>
            .          .          .                      .                  .               .                   .               .               .                   constexpr _Head_base(_UHead&& __h)
    8,734,443 ( 0.00%) 2 ( 0.02%) 2 ( 0.03%)     1,146,885 ( 0.00%) 1,146,750 ( 0.01%)      0           3,146,903 ( 0.00%)  9,481 ( 0.00%)      0           	: _M_head_impl(std::forward<_UHead>(__h)) { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 _GLIBCXX20_CONSTEXPR
            .          .          .                      .                  .               .                   .               .               .                 _Head_base(allocator_arg_t, __uses_alloc0)
            .          .          .                      .                  .               .                   .               .               .                 : _M_head_impl() { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 template<typename _Alloc>
            .          .          .                      .                  .               .                   .               .               .           	_GLIBCXX20_CONSTEXPR
            .          .          .                      .                  .               .                   .               .               .           	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
-- line 208 ----------------------------------------
-- line 225 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .           	{ }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 template<typename _Alloc, typename _UHead>
            .          .          .                      .                  .               .                   .               .               .           	_GLIBCXX20_CONSTEXPR
            .          .          .                      .                  .               .                   .               .               .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
            .          .          .                      .                  .               .                   .               .               .           	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 static constexpr _Head&
        2,796 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)             0                  0               0                 932 ( 0.00%)    625 ( 0.00%)      0                 _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 static constexpr const _Head&
            .          .          .                      .                  .               .                   .               .               .                 _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 _Head _M_head_impl;
            .          .          .                      .                  .               .                   .               .               .               };
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .             /**
-- line 241 ----------------------------------------
-- line 293 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .           	{ }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
            .          .          .                      .                  .               .                   .               .               .                 // 2729. Missing SFINAE on std::pair::operator=
            .          .          .                      .                  .               .                   .               .               .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
            .          .          .                      .                  .               .                   .               .               .           
    5,445,640 ( 0.00%) 0          0              2,722,820 ( 0.00%)    24,866 ( 0.00%) 20,751 ( 0.00%)  2,722,820 ( 0.00%) 36,164 ( 0.00%) 12,732 ( 0.01%)        _Tuple_impl(_Tuple_impl&&) = default;
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 template<typename... _UElements>
            .          .          .                      .                  .               .                   .               .               .           	constexpr
            .          .          .                      .                  .               .                   .               .               .           	_Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
            .          .          .                      .                  .               .                   .               .               .           	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
            .          .          .                      .                  .               .                   .               .               .           	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
            .          .          .                      .                  .               .                   .               .               .           	{ }
            .          .          .                      .                  .               .                   .               .               .           
-- line 309 ----------------------------------------
-- line 448 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .           #if _GLIBCXX_INLINE_VERSION
            .          .          .                      .                  .               .                   .               .               .                 _Tuple_impl(_Tuple_impl&&) = default;
            .          .          .                      .                  .               .                   .               .               .           #else
            .          .          .                      .                  .               .                   .               .               .                 constexpr
            .          .          .                      .                  .               .                   .               .               .                 _Tuple_impl(_Tuple_impl&& __in)
            .          .          .                      .                  .               .                   .               .               .                 noexcept(is_nothrow_move_constructible<_Head>::value)
    6,163,475 ( 0.00%) 0          0              1,361,410 ( 0.00%)    92,507 ( 0.00%) 66,092 ( 0.00%)  2,508,295 ( 0.00%) 89,342 ( 0.00%) 70,791 ( 0.08%)        : _Base(static_cast<_Base&&>(__in))
            .          .          .                      .                  .               .                   .               .               .                 { }
            .          .          .                      .                  .               .                   .               .               .           #endif
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 template<typename _UHead>
            .          .          .                      .                  .               .                   .               .               .           	constexpr
            .          .          .                      .                  .               .                   .               .               .           	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
            .          .          .                      .                  .               .                   .               .               .           	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
            .          .          .                      .                  .               .                   .               .               .           	{ }
-- line 464 ----------------------------------------
-- line 1493 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .               }
            .          .          .                      .                  .               .                   .               .               .           #endif
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .             // This class performs the comparison operations on tuples
            .          .          .                      .                  .               .                   .               .               .             template<typename _Tp, typename _Up, size_t __i, size_t __size>
            .          .          .                      .                  .               .                   .               .               .               struct __tuple_compare
            .          .          .                      .                  .               .                   .               .               .               {
            .          .          .                      .                  .               .                   .               .               .                 static constexpr bool
1,708,613,909 ( 0.07%) 0          0          1,708,613,909 ( 0.36%)         0               0                   0               0               0                 __eq(const _Tp& __t, const _Up& __u)
            .          .          .                      .                  .               .                   .               .               .                 {
            .          .          .                      .                  .               .                   .               .               .           	return bool(std::get<__i>(__t) == std::get<__i>(__u))
5,501,668,422 ( 0.24%) 2 ( 0.02%) 2 ( 0.03%) 2,460,833,949 ( 0.52%)         0               0                   0               0               0           	  && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
            .          .          .                      .                  .               .                   .               .               .                 }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .                 static constexpr bool
            .          .          .                      .                  .               .                   .               .               .                 __less(const _Tp& __t, const _Up& __u)
            .          .          .                      .                  .               .                   .               .               .                 {
            .          .          .                      .                  .               .                   .               .               .           	return bool(std::get<__i>(__t) < std::get<__i>(__u))
            .          .          .                      .                  .               .                   .               .               .           	  || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
            .          .          .                      .                  .               .                   .               .               .           	      && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
-- line 1512 ----------------------------------------
-- line 1815 ----------------------------------------
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .             template<class _T1, class _T2>
            .          .          .                      .                  .               .                   .               .               .               template<typename... _Args1, size_t... _Indexes1,
            .          .          .                      .                  .               .                   .               .               .           	     typename... _Args2, size_t... _Indexes2>
            .          .          .                      .                  .               .                   .               .               .                 _GLIBCXX20_CONSTEXPR inline
            .          .          .                      .                  .               .                   .               .               .                 pair<_T1, _T2>::
            .          .          .                      .                  .               .                   .               .               .                 pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
            .          .          .                      .                  .               .                   .               .               .           	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
   67,285,863 ( 0.00%) 0          0                      0                  0               0          67,285,863 ( 0.01%)      4 ( 0.00%)      1 ( 0.00%)        : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
   67,285,862 ( 0.00%) 0          0                      0                  0               0          67,285,862 ( 0.01%)      0               0           	second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
            .          .          .                      .                  .               .                   .               .               .                 { }
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .           #if __cplusplus >= 201703L
            .          .          .                      .                  .               .                   .               .               .           
            .          .          .                      .                  .               .                   .               .               .             // Unpack a std::tuple into a type trait and use its value.
            .          .          .                      .                  .               .                   .               .               .             // For cv std::tuple<_Up> the result is _Trait<_Tp, cv _Up...>::value.
            .          .          .                      .                  .               .                   .               .               .             // For cv std::tuple<_Up>& the result is _Trait<_Tp, cv _Up&...>::value.
            .          .          .                      .                  .               .                   .               .               .             // Otherwise the result is false (because we don't know if std::get throws).
-- line 1832 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/zhenhao/bucket-map/build/_deps/seqan3-src/include/seqan3/utility/math.hpp
--------------------------------------------------------------------------------
Ir                      I1mr       ILmr       Dr                     D1mr            DLmr       Dw                     D1mw            DLmw       

-- line 114 ----------------------------------------
             .          .          .                      .               .          .                      .               .          .            * In all other cases the return value and type is equivalent to that of `std::pow`.
             .          .          .                      .               .          .                      .               .          .            *
             .          .          .                      .               .          .                      .               .          .            * ### Example
             .          .          .                      .               .          .                      .               .          .            *
             .          .          .                      .               .          .                      .               .          .            * \include test/snippet/utility/pow.cpp
             .          .          .                      .               .          .                      .               .          .            */
             .          .          .                      .               .          .                      .               .          .           template <typename base_t, std::unsigned_integral exp_t>
             .          .          .                      .               .          .                      .               .          .               requires (std::same_as<base_t, uint64_t> || std::same_as<base_t, int64_t>)
 4,762,433,380 ( 0.20%) 4 ( 0.05%) 4 ( 0.06%)   476,243,338 ( 0.10%) 26,506 ( 0.00%) 0          2,857,460,028 ( 0.49%) 26,511 ( 0.00%) 1 ( 0.00%)  base_t pow(base_t base, exp_t exp)
             .          .          .                      .               .          .                      .               .          .           {
   476,243,338 ( 0.02%) 0          0                      0               0          0                      0               0          0               base_t result{1};
             .          .          .                      .               .          .                      .               .          .           #ifndef NDEBUG
 1,428,730,014 ( 0.06%) 0          0                      0               0          0                      0               0          0               if (base == 0)
             .          .          .                      .               .          .                      .               .          .                   return 0;
             .          .          .                      .               .          .                      .               .          .           
17,235,237,294 ( 0.74%) 2 ( 0.02%) 2 ( 0.03%)             0               0          0                      0               0          0               for (exp_t i = 0; i < exp; ++i)
             .          .          .                      .               .          .                      .               .          .               {
14,377,777,266 ( 0.62%) 0          0                      0               0          0                      0               0          0                   if ((base < 0 ? std::numeric_limits<base_t>::min() : std::numeric_limits<base_t>::max()) / base < result)
             .          .          .                      .               .          .                      .               .          .                   {
             .          .          .                      .               .          .                      .               .          .                       std::string error_message{"Calculating " + std::to_string(base) + '^' + std::to_string(exp)
             .          .          .                      .               .          .                      .               .          .                                                 + " will result in an "
             .          .          .                      .               .          .                      .               .          .                                                 + (std::same_as<base_t, int64_t> ? "int64_t" : "uint64_t")};
             .          .          .                      .               .          .                      .               .          .                       if (base < 0)
             .          .          .                      .               .          .                      .               .          .                           throw std::underflow_error{error_message + " underflow."};
             .          .          .                      .               .          .                      .               .          .                       else
             .          .          .                      .               .          .                      .               .          .                           throw std::overflow_error{error_message + " overflow."};
             .          .          .                      .               .          .                      .               .          .                   }
 5,268,835,760 ( 0.23%) 0          0                      0               0          0                      0               0          0                   result *= base;
             .          .          .                      .               .          .                      .               .          .               }
             .          .          .                      .               .          .                      .               .          .           #else
             .          .          .                      .               .          .                      .               .          .               for (; exp; exp >>= 1, base *= base)
             .          .          .                      .               .          .                      .               .          .                   result *= (exp & 1) ? base : 1;
             .          .          .                      .               .          .                      .               .          .           #endif
             .          .          .                      .               .          .                      .               .          .               return result;
 5,238,676,718 ( 0.22%) 0          0          3,809,946,704 ( 0.80%)      0          0                      0               0          0           }
             .          .          .                      .               .          .                      .               .          .           
             .          .          .                      .               .          .                      .               .          .           //!\cond
             .          .          .                      .               .          .                      .               .          .           // If base and exponent are unsigned integrals, promote the base to `uint64_t`.
             .          .          .                      .               .          .                      .               .          .           template <std::integral base_t, std::unsigned_integral exp_t>
             .          .          .                      .               .          .                      .               .          .               requires (std::unsigned_integral<base_t> && !std::same_as<base_t, uint64_t>)
   231,095,162 ( 0.01%) 0          0                      0               0          0            231,095,162 ( 0.04%)      0          0           uint64_t pow(base_t base, exp_t exp)
             .          .          .                      .               .          .                      .               .          .           {
 1,193,687,866 ( 0.05%) 1 ( 0.01%) 1 ( 0.01%)             0               0          0            717,444,528 ( 0.12%)      0          0               return pow(static_cast<uint64_t>(base), exp);
             .          .          .                      .               .          .                      .               .          .           }
             .          .          .                      .               .          .                      .               .          .           
             .          .          .                      .               .          .                      .               .          .           // If the base is a signed integral and the exponent is an unsigned integral, promote the base to `int64_t`.
             .          .          .                      .               .          .                      .               .          .           template <std::integral base_t, std::unsigned_integral exp_t>
             .          .          .                      .               .          .                      .               .          .               requires (!std::unsigned_integral<base_t> && !std::same_as<base_t, int64_t>)
             .          .          .                      .               .          .                      .               .          .           int64_t pow(base_t base, exp_t exp)
             .          .          .                      .               .          .                      .               .          .           {
             .          .          .                      .               .          .                      .               .          .               return pow(static_cast<int64_t>(base), exp);
-- line 164 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir                         I1mr         ILmr         Dr                       D1mr                   DLmr                   Dw                       D1mw                 DLmw                
--------------------------------------------------------------------------------
1,566,231,030,993 (67.25%) 438 ( 5.41%) 434 ( 6.10%) 352,569,980,049 (73.99%) 7,371,392,309 (71.59%) 1,640,093,232 (98.43%) 202,240,300,330 (34.46%) 448,260,326 ( 7.86%) 27,348,898 (31.60%)  events annotated

